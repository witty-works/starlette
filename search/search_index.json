{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u2728 The little ASGI framework that shines. \u2728 Introduction Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services. It is production-ready, and gives you the following: Seriously impressive performance. WebSocket support. In-process background tasks. Startup and shutdown events. Test client built on requests . CORS, GZip, Static Files, Streaming responses. Session and Cookie support. 100% test coverage. 100% type annotated codebase. Few hard dependencies. Requirements Python 3.6+ Installation $ pip3 install starlette You'll also want to install an ASGI server, such as uvicorn , daphne , or hypercorn . $ pip3 install uvicorn Example example.py : from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route async def homepage ( request ): return JSONResponse ({ 'hello' : 'world' }) app = Starlette ( debug = True , routes = [ Route ( '/' , homepage ), ]) Then run the application... $ uvicorn example:app For a more complete example, see here . Dependencies Starlette only requires anyio , and the following dependencies are optional: requests - Required if you want to use the TestClient . jinja2 - Required if you want to use Jinja2Templates . python-multipart - Required if you want to support form parsing, with request.form() . itsdangerous - Required for SessionMiddleware support. pyyaml - Required for SchemaGenerator support. You can install all of these with pip3 install starlette[full] . Framework or Toolkit Starlette is designed to be used either as a complete framework, or as an ASGI toolkit. You can use any of its components independently. from starlette.responses import PlainTextResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = PlainTextResponse ( 'Hello, world!' ) await response ( scope , receive , send ) Run the app application in example.py : $ uvicorn example:app INFO: Started server process [ 11509 ] INFO: Uvicorn running on http://127.0.0.1:8000 ( Press CTRL+C to quit ) Run uvicorn with --reload to enable auto-reloading on code changes. Modularity The modularity that Starlette is designed on promotes building re-usable components that can be shared between any ASGI framework. This should enable an ecosystem of shared middleware and mountable applications. The clean API separation also means it's easier to understand each component in isolation. Performance Independent TechEmpower benchmarks show Starlette applications running under Uvicorn as one of the fastest Python frameworks available . (*) For high throughput loads you should: Run using Gunicorn using the uvicorn worker class. Use one or two workers per-CPU core. (You might need to experiment with this.) Disable access logging. For example: gunicorn -w 4 -k uvicorn.workers.UvicornWorker --log-level warning example:app Several of the ASGI servers also have pure Python implementations available, so you can also run under PyPy if your application code has parts that are CPU constrained. Either programatically: uvicorn . run ( ... , http = 'h11' , loop = 'asyncio' ) Or using Gunicorn: gunicorn -k uvicorn.workers.UvicornH11Worker ... \u2014 \u2b50\ufe0f \u2014 Starlette is BSD licensed code. Designed & built in Brighton, England.","title":"Introduction"},{"location":"#introduction","text":"Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services. It is production-ready, and gives you the following: Seriously impressive performance. WebSocket support. In-process background tasks. Startup and shutdown events. Test client built on requests . CORS, GZip, Static Files, Streaming responses. Session and Cookie support. 100% test coverage. 100% type annotated codebase. Few hard dependencies.","title":"Introduction"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation","text":"$ pip3 install starlette You'll also want to install an ASGI server, such as uvicorn , daphne , or hypercorn . $ pip3 install uvicorn","title":"Installation"},{"location":"#example","text":"example.py : from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route async def homepage ( request ): return JSONResponse ({ 'hello' : 'world' }) app = Starlette ( debug = True , routes = [ Route ( '/' , homepage ), ]) Then run the application... $ uvicorn example:app For a more complete example, see here .","title":"Example"},{"location":"#dependencies","text":"Starlette only requires anyio , and the following dependencies are optional: requests - Required if you want to use the TestClient . jinja2 - Required if you want to use Jinja2Templates . python-multipart - Required if you want to support form parsing, with request.form() . itsdangerous - Required for SessionMiddleware support. pyyaml - Required for SchemaGenerator support. You can install all of these with pip3 install starlette[full] .","title":"Dependencies"},{"location":"#framework-or-toolkit","text":"Starlette is designed to be used either as a complete framework, or as an ASGI toolkit. You can use any of its components independently. from starlette.responses import PlainTextResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = PlainTextResponse ( 'Hello, world!' ) await response ( scope , receive , send ) Run the app application in example.py : $ uvicorn example:app INFO: Started server process [ 11509 ] INFO: Uvicorn running on http://127.0.0.1:8000 ( Press CTRL+C to quit ) Run uvicorn with --reload to enable auto-reloading on code changes.","title":"Framework or Toolkit"},{"location":"#modularity","text":"The modularity that Starlette is designed on promotes building re-usable components that can be shared between any ASGI framework. This should enable an ecosystem of shared middleware and mountable applications. The clean API separation also means it's easier to understand each component in isolation.","title":"Modularity"},{"location":"#performance","text":"Independent TechEmpower benchmarks show Starlette applications running under Uvicorn as one of the fastest Python frameworks available . (*) For high throughput loads you should: Run using Gunicorn using the uvicorn worker class. Use one or two workers per-CPU core. (You might need to experiment with this.) Disable access logging. For example: gunicorn -w 4 -k uvicorn.workers.UvicornWorker --log-level warning example:app Several of the ASGI servers also have pure Python implementations available, so you can also run under PyPy if your application code has parts that are CPU constrained. Either programatically: uvicorn . run ( ... , http = 'h11' , loop = 'asyncio' ) Or using Gunicorn: gunicorn -k uvicorn.workers.UvicornH11Worker ... \u2014 \u2b50\ufe0f \u2014 Starlette is BSD licensed code. Designed & built in Brighton, England.","title":"Performance"},{"location":"applications/","text":"Starlette includes an application class Starlette that nicely ties together all of its other functionality. from starlette.applications import Starlette from starlette.responses import PlainTextResponse from starlette.routing import Route , Mount , WebSocketRoute from starlette.staticfiles import StaticFiles def homepage ( request ): return PlainTextResponse ( 'Hello, world!' ) def user_me ( request ): username = \"John Doe\" return PlainTextResponse ( 'Hello, %s !' % username ) def user ( request ): username = request . path_params [ 'username' ] return PlainTextResponse ( 'Hello, %s !' % username ) async def websocket_endpoint ( websocket ): await websocket . accept () await websocket . send_text ( 'Hello, websocket!' ) await websocket . close () def startup (): print ( 'Ready to go' ) routes = [ Route ( '/' , homepage ), Route ( '/user/me' , user_me ), Route ( '/user/ {username} ' , user ), WebSocketRoute ( '/ws' , websocket_endpoint ), Mount ( '/static' , StaticFiles ( directory = \"static\" )), ] app = Starlette ( debug = True , routes = routes , on_startup = [ startup ]) Instantiating the application class starlette.applications. Starlette ( debug=False , routes=None , middleware=None , exception_handlers=None , on_startup=None , on_shutdown=None , lifespan=None ) Creates an application instance. Parameters: debug - Boolean indicating if debug tracebacks should be returned on errors. routes - A list of routes to serve incoming HTTP and WebSocket requests. middleware - A list of middleware to run for every request. A starlette application will always automatically include two middleware classes. ServerErrorMiddleware is added as the very outermost middleware, to handle any uncaught errors occurring anywhere in the entire stack. ExceptionMiddleware is added as the very innermost middleware, to deal with handled exception cases occurring in the routing or endpoints. exception_handlers - A dictionary mapping either integer status codes, or exception class types onto callables which handle the exceptions. Exception handler callables should be of the form handler(request, exc) -> response and may be be either standard functions, or async functions. on_startup - A list of callables to run on application startup. Startup handler callables do not take any arguments, and may be be either standard functions, or async functions. on_shutdown - A list of callables to run on application shutdown. Shutdown handler callables do not take any arguments, and may be be either standard functions, or async functions. Storing state on the app instance You can store arbitrary extra state on the application instance, using the generic app.state attribute. For example: app . state . ADMIN_EMAIL = 'admin@example.org' Accessing the app instance Where a request is available (i.e. endpoints and middleware), the app is available on request.app .","title":"Applications"},{"location":"applications/#instantiating-the-application","text":"class starlette.applications. Starlette ( debug=False , routes=None , middleware=None , exception_handlers=None , on_startup=None , on_shutdown=None , lifespan=None ) Creates an application instance. Parameters: debug - Boolean indicating if debug tracebacks should be returned on errors. routes - A list of routes to serve incoming HTTP and WebSocket requests. middleware - A list of middleware to run for every request. A starlette application will always automatically include two middleware classes. ServerErrorMiddleware is added as the very outermost middleware, to handle any uncaught errors occurring anywhere in the entire stack. ExceptionMiddleware is added as the very innermost middleware, to deal with handled exception cases occurring in the routing or endpoints. exception_handlers - A dictionary mapping either integer status codes, or exception class types onto callables which handle the exceptions. Exception handler callables should be of the form handler(request, exc) -> response and may be be either standard functions, or async functions. on_startup - A list of callables to run on application startup. Startup handler callables do not take any arguments, and may be be either standard functions, or async functions. on_shutdown - A list of callables to run on application shutdown. Shutdown handler callables do not take any arguments, and may be be either standard functions, or async functions.","title":"Instantiating the application"},{"location":"applications/#storing-state-on-the-app-instance","text":"You can store arbitrary extra state on the application instance, using the generic app.state attribute. For example: app . state . ADMIN_EMAIL = 'admin@example.org'","title":"Storing state on the app instance"},{"location":"applications/#accessing-the-app-instance","text":"Where a request is available (i.e. endpoints and middleware), the app is available on request.app .","title":"Accessing the app instance"},{"location":"authentication/","text":"Starlette offers a simple but powerful interface for handling authentication and permissions. Once you've installed AuthenticationMiddleware with an appropriate authentication backend the request.user and request.auth interfaces will be available in your endpoints. from starlette.applications import Starlette from starlette.authentication import ( AuthenticationBackend , AuthenticationError , SimpleUser , UnauthenticatedUser , AuthCredentials ) from starlette.middleware import Middleware from starlette.middleware.authentication import AuthenticationMiddleware from starlette.responses import PlainTextResponse from starlette.routing import Route import base64 import binascii class BasicAuthBackend ( AuthenticationBackend ): async def authenticate ( self , request ): if \"Authorization\" not in request . headers : return auth = request . headers [ \"Authorization\" ] try : scheme , credentials = auth . split () if scheme . lower () != 'basic' : return decoded = base64 . b64decode ( credentials ) . decode ( \"ascii\" ) except ( ValueError , UnicodeDecodeError , binascii . Error ) as exc : raise AuthenticationError ( 'Invalid basic auth credentials' ) username , _ , password = decoded . partition ( \":\" ) # TODO: You'd want to verify the username and password here. return AuthCredentials ([ \"authenticated\" ]), SimpleUser ( username ) async def homepage ( request ): if request . user . is_authenticated : return PlainTextResponse ( 'Hello, ' + request . user . display_name ) return PlainTextResponse ( 'Hello, you' ) routes = [ Route ( \"/\" , endpoint = homepage ) ] middleware = [ Middleware ( AuthenticationMiddleware , backend = BasicAuthBackend ()) ] app = Starlette ( routes = routes , middleware = middleware ) Users Once AuthenticationMiddleware is installed the request.user interface will be available to endpoints or other middleware. This interface should subclass BaseUser , which provides two properties, as well as whatever other information your user model includes. .is_authenticated .display_name Starlette provides two built-in user implementations: UnauthenticatedUser() , and SimpleUser(username) . AuthCredentials It is important that authentication credentials are treated as separate concept from users. An authentication scheme should be able to restrict or grant particular privileges independently of the user identity. The AuthCredentials class provides the basic interface that request.auth exposes: .scopes Permissions Permissions are implemented as an endpoint decorator, that enforces that the incoming request includes the required authentication scopes. from starlette.authentication import requires @requires ( 'authenticated' ) async def dashboard ( request ): ... You can include either one or multiple required scopes: from starlette.authentication import requires @requires ([ 'authenticated' , 'admin' ]) async def dashboard ( request ): ... By default 403 responses will be returned when permissions are not granted. In some cases you might want to customize this, for example to hide information about the URL layout from unauthenticated users. from starlette.authentication import requires @requires ([ 'authenticated' , 'admin' ], status_code = 404 ) async def dashboard ( request ): ... Alternatively you might want to redirect unauthenticated users to a different page. from starlette.authentication import requires async def homepage ( request ): ... @requires ( 'authenticated' , redirect = 'homepage' ) async def dashboard ( request ): ... For class-based endpoints, you should wrap the decorator around a method on the class. class Dashboard ( HTTPEndpoint ): @requires ( \"authenticated\" ) async def get ( self , request ): ... Custom authentication error responses You can customise the error response sent when a AuthenticationError is raised by an auth backend: def on_auth_error ( request : Request , exc : Exception ): return JSONResponse ({ \"error\" : str ( exc )}, status_code = 401 ) app . add_middleware ( AuthenticationMiddleware , backend = BasicAuthBackend (), on_error = on_auth_error )","title":"Authentication"},{"location":"authentication/#users","text":"Once AuthenticationMiddleware is installed the request.user interface will be available to endpoints or other middleware. This interface should subclass BaseUser , which provides two properties, as well as whatever other information your user model includes. .is_authenticated .display_name Starlette provides two built-in user implementations: UnauthenticatedUser() , and SimpleUser(username) .","title":"Users"},{"location":"authentication/#authcredentials","text":"It is important that authentication credentials are treated as separate concept from users. An authentication scheme should be able to restrict or grant particular privileges independently of the user identity. The AuthCredentials class provides the basic interface that request.auth exposes: .scopes","title":"AuthCredentials"},{"location":"authentication/#permissions","text":"Permissions are implemented as an endpoint decorator, that enforces that the incoming request includes the required authentication scopes. from starlette.authentication import requires @requires ( 'authenticated' ) async def dashboard ( request ): ... You can include either one or multiple required scopes: from starlette.authentication import requires @requires ([ 'authenticated' , 'admin' ]) async def dashboard ( request ): ... By default 403 responses will be returned when permissions are not granted. In some cases you might want to customize this, for example to hide information about the URL layout from unauthenticated users. from starlette.authentication import requires @requires ([ 'authenticated' , 'admin' ], status_code = 404 ) async def dashboard ( request ): ... Alternatively you might want to redirect unauthenticated users to a different page. from starlette.authentication import requires async def homepage ( request ): ... @requires ( 'authenticated' , redirect = 'homepage' ) async def dashboard ( request ): ... For class-based endpoints, you should wrap the decorator around a method on the class. class Dashboard ( HTTPEndpoint ): @requires ( \"authenticated\" ) async def get ( self , request ): ...","title":"Permissions"},{"location":"authentication/#custom-authentication-error-responses","text":"You can customise the error response sent when a AuthenticationError is raised by an auth backend: def on_auth_error ( request : Request , exc : Exception ): return JSONResponse ({ \"error\" : str ( exc )}, status_code = 401 ) app . add_middleware ( AuthenticationMiddleware , backend = BasicAuthBackend (), on_error = on_auth_error )","title":"Custom authentication error responses"},{"location":"background/","text":"Starlette includes a BackgroundTask class for in-process background tasks. A background task should be attached to a response, and will run only once the response has been sent. Background Task Used to add a single background task to a response. Signature: BackgroundTask(func, *args, **kwargs) from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route from starlette.background import BackgroundTask ... async def signup ( request ): data = await request . json () username = data [ 'username' ] email = data [ 'email' ] task = BackgroundTask ( send_welcome_email , to_address = email ) message = { 'status' : 'Signup successful' } return JSONResponse ( message , background = task ) async def send_welcome_email ( to_address ): ... routes = [ ... Route ( '/user/signup' , endpoint = signup , methods = [ 'POST' ]) ] app = Starlette ( routes = routes ) BackgroundTasks Used to add multiple background tasks to a response. Signature: BackgroundTasks(tasks=[]) from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.background import BackgroundTasks async def signup ( request ): data = await request . json () username = data [ 'username' ] email = data [ 'email' ] tasks = BackgroundTasks () tasks . add_task ( send_welcome_email , to_address = email ) tasks . add_task ( send_admin_notification , username = username ) message = { 'status' : 'Signup successful' } return JSONResponse ( message , background = tasks ) async def send_welcome_email ( to_address ): ... async def send_admin_notification ( username ): ... routes = [ Route ( '/user/signup' , endpoint = signup , methods = [ 'POST' ]) ] app = Starlette ( routes = routes )","title":"Background Tasks"},{"location":"background/#background-task","text":"Used to add a single background task to a response. Signature: BackgroundTask(func, *args, **kwargs) from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route from starlette.background import BackgroundTask ... async def signup ( request ): data = await request . json () username = data [ 'username' ] email = data [ 'email' ] task = BackgroundTask ( send_welcome_email , to_address = email ) message = { 'status' : 'Signup successful' } return JSONResponse ( message , background = task ) async def send_welcome_email ( to_address ): ... routes = [ ... Route ( '/user/signup' , endpoint = signup , methods = [ 'POST' ]) ] app = Starlette ( routes = routes )","title":"Background Task"},{"location":"background/#backgroundtasks","text":"Used to add multiple background tasks to a response. Signature: BackgroundTasks(tasks=[]) from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.background import BackgroundTasks async def signup ( request ): data = await request . json () username = data [ 'username' ] email = data [ 'email' ] tasks = BackgroundTasks () tasks . add_task ( send_welcome_email , to_address = email ) tasks . add_task ( send_admin_notification , username = username ) message = { 'status' : 'Signup successful' } return JSONResponse ( message , background = tasks ) async def send_welcome_email ( to_address ): ... async def send_admin_notification ( username ): ... routes = [ Route ( '/user/signup' , endpoint = signup , methods = [ 'POST' ]) ] app = Starlette ( routes = routes )","title":"BackgroundTasks"},{"location":"config/","text":"Starlette encourages a strict separation of configuration from code, following the twelve-factor pattern . Configuration should be stored in environment variables, or in a \".env\" file that is not committed to source control. app.py : import databases from starlette.applications import Starlette from starlette.config import Config from starlette.datastructures import CommaSeparatedStrings , Secret # Config will be read from environment variables and/or \".env\" files. config = Config ( \".env\" ) DEBUG = config ( 'DEBUG' , cast = bool , default = False ) DATABASE_URL = config ( 'DATABASE_URL' , cast = databases . DatabaseURL ) SECRET_KEY = config ( 'SECRET_KEY' , cast = Secret ) ALLOWED_HOSTS = config ( 'ALLOWED_HOSTS' , cast = CommaSeparatedStrings ) app = Starlette ( debug = DEBUG ) ... .env : # Don't commit this to source control. # Eg. Include \".env\" in your `.gitignore` file. DEBUG = True DATABASE_URL = postgresql://localhost/myproject SECRET_KEY = 43n080musdfjt54t-09sdgr ALLOWED_HOSTS = 127 .0.0.1, localhost Configuration precedence The order in which configuration values are read is: From an environment variable. From the \".env\" file. The default value given in config . If none of those match, then config(...) will raise an error. Secrets For sensitive keys, the Secret class is useful, since it helps minimize occasions where the value it holds could leak out into tracebacks or other code introspection. To get the value of a Secret instance, you must explicitly cast it to a string. You should only do this at the point at which the value is used. >>> from myproject import settings >>> settings . SECRET_KEY Secret ( '**********' ) >>> str ( settings . SECRET_KEY ) '98n349$%8b8-7yjn0n8y93T$23r' Similarly, the URL class will hide any password component in their representations. >>> from myproject import settings >>> settings . DATABASE_URL DatabaseURL ( 'postgresql://admin:**********@192.168.0.8/my-application' ) >>> str ( settings . DATABASE_URL ) 'postgresql://admin:Fkjh348htGee4t3@192.168.0.8/my-application' CommaSeparatedStrings For holding multiple inside a single config key, the CommaSeparatedStrings type is useful. >>> from myproject import settings >>> print ( settings . ALLOWED_HOSTS ) CommaSeparatedStrings ([ '127.0.0.1' , 'localhost' ]) >>> print ( list ( settings . ALLOWED_HOSTS )) [ '127.0.0.1' , 'localhost' ] >>> print ( len ( settings . ALLOWED_HOSTS )) 2 >>> print ( settings . ALLOWED_HOSTS [ 0 ]) '127.0.0.1' Reading or modifying the environment In some cases you might want to read or modify the environment variables programmatically. This is particularly useful in testing, where you may want to override particular keys in the environment. Rather than reading or writing from os.environ , you should use Starlette's environ instance. This instance is a mapping onto the standard os.environ that additionally protects you by raising an error if any environment variable is set after the point that it has already been read by the configuration. If you're using pytest , then you can setup any initial environment in tests/conftest.py . tests/conftest.py : from starlette.config import environ environ [ 'TESTING' ] = 'TRUE' A full example Structuring large applications can be complex. You need proper separation of configuration and code, database isolation during tests, separate test and production databases, etc... Here we'll take a look at a complete example, that demonstrates how we can start to structure an application. First, let's keep our settings, our database table definitions, and our application logic separated: myproject/settings.py : from starlette.config import Config from starlette.datastructures import URL , Secret config = Config ( \".env\" ) DEBUG = config ( 'DEBUG' , cast = bool , default = False ) TESTING = config ( 'TESTING' , cast = bool , default = False ) SECRET_KEY = config ( 'SECRET_KEY' , cast = Secret ) DATABASE_URL = config ( 'DATABASE_URL' , cast = URL ) if TESTING : DATABASE_URL = DATABASE_URL . replace ( database = 'test_' + DATABASE_URL . database ) myproject/tables.py : import sqlalchemy # Database table definitions. metadata = sqlalchemy . MetaData () organisations = sqlalchemy . Table ( ... ) myproject/app.py from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.session import SessionMiddleware from starlette.routing import Route from myproject import settings async def homepage ( request ): ... routes = [ Route ( \"/\" , endpoint = homepage ) ] middleware = [ Middleware ( SessionMiddleware , secret_key = settings . SECRET_KEY , ) ] app = Starlette ( debug = settings . DEBUG , routes = routes , middleware = middleware ) Now let's deal with our test configuration. We'd like to create a new test database every time the test suite runs, and drop it once the tests complete. We'd also like to ensure tests/conftest.py : from starlette.config import environ from starlette.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy_utils import database_exists , create_database # This line would raise an error if we use it after 'settings' has been imported. environ [ 'TESTING' ] = 'TRUE' from myproject import settings from myproject.app import app from myproject.tables import metadata @pytest . fixture ( autouse = True , scope = \"session\" ) def setup_test_database (): \"\"\" Create a clean test database every time the tests are run. \"\"\" url = str ( settings . DATABASE_URL ) engine = create_engine ( url ) assert not database_exists ( url ), 'Test database already exists. Aborting tests.' create_database ( url ) # Create the test database. metadata . create_all ( engine ) # Create the tables. yield # Run the tests. drop_database ( url ) # Drop the test database. @pytest . fixture () def client (): \"\"\" Make a 'client' fixture available to test cases. \"\"\" # Our fixture is created within a context manager. This ensures that # application startup and shutdown run for every test case. # # Because we've configured the DatabaseMiddleware with `rollback_on_shutdown` # we'll get a complete rollback to the initial state after each test case runs. with TestClient ( app ) as test_client : yield test_client","title":"Configuration"},{"location":"config/#configuration-precedence","text":"The order in which configuration values are read is: From an environment variable. From the \".env\" file. The default value given in config . If none of those match, then config(...) will raise an error.","title":"Configuration precedence"},{"location":"config/#secrets","text":"For sensitive keys, the Secret class is useful, since it helps minimize occasions where the value it holds could leak out into tracebacks or other code introspection. To get the value of a Secret instance, you must explicitly cast it to a string. You should only do this at the point at which the value is used. >>> from myproject import settings >>> settings . SECRET_KEY Secret ( '**********' ) >>> str ( settings . SECRET_KEY ) '98n349$%8b8-7yjn0n8y93T$23r' Similarly, the URL class will hide any password component in their representations. >>> from myproject import settings >>> settings . DATABASE_URL DatabaseURL ( 'postgresql://admin:**********@192.168.0.8/my-application' ) >>> str ( settings . DATABASE_URL ) 'postgresql://admin:Fkjh348htGee4t3@192.168.0.8/my-application'","title":"Secrets"},{"location":"config/#commaseparatedstrings","text":"For holding multiple inside a single config key, the CommaSeparatedStrings type is useful. >>> from myproject import settings >>> print ( settings . ALLOWED_HOSTS ) CommaSeparatedStrings ([ '127.0.0.1' , 'localhost' ]) >>> print ( list ( settings . ALLOWED_HOSTS )) [ '127.0.0.1' , 'localhost' ] >>> print ( len ( settings . ALLOWED_HOSTS )) 2 >>> print ( settings . ALLOWED_HOSTS [ 0 ]) '127.0.0.1'","title":"CommaSeparatedStrings"},{"location":"config/#reading-or-modifying-the-environment","text":"In some cases you might want to read or modify the environment variables programmatically. This is particularly useful in testing, where you may want to override particular keys in the environment. Rather than reading or writing from os.environ , you should use Starlette's environ instance. This instance is a mapping onto the standard os.environ that additionally protects you by raising an error if any environment variable is set after the point that it has already been read by the configuration. If you're using pytest , then you can setup any initial environment in tests/conftest.py . tests/conftest.py : from starlette.config import environ environ [ 'TESTING' ] = 'TRUE'","title":"Reading or modifying the environment"},{"location":"config/#a-full-example","text":"Structuring large applications can be complex. You need proper separation of configuration and code, database isolation during tests, separate test and production databases, etc... Here we'll take a look at a complete example, that demonstrates how we can start to structure an application. First, let's keep our settings, our database table definitions, and our application logic separated: myproject/settings.py : from starlette.config import Config from starlette.datastructures import URL , Secret config = Config ( \".env\" ) DEBUG = config ( 'DEBUG' , cast = bool , default = False ) TESTING = config ( 'TESTING' , cast = bool , default = False ) SECRET_KEY = config ( 'SECRET_KEY' , cast = Secret ) DATABASE_URL = config ( 'DATABASE_URL' , cast = URL ) if TESTING : DATABASE_URL = DATABASE_URL . replace ( database = 'test_' + DATABASE_URL . database ) myproject/tables.py : import sqlalchemy # Database table definitions. metadata = sqlalchemy . MetaData () organisations = sqlalchemy . Table ( ... ) myproject/app.py from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.session import SessionMiddleware from starlette.routing import Route from myproject import settings async def homepage ( request ): ... routes = [ Route ( \"/\" , endpoint = homepage ) ] middleware = [ Middleware ( SessionMiddleware , secret_key = settings . SECRET_KEY , ) ] app = Starlette ( debug = settings . DEBUG , routes = routes , middleware = middleware ) Now let's deal with our test configuration. We'd like to create a new test database every time the test suite runs, and drop it once the tests complete. We'd also like to ensure tests/conftest.py : from starlette.config import environ from starlette.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy_utils import database_exists , create_database # This line would raise an error if we use it after 'settings' has been imported. environ [ 'TESTING' ] = 'TRUE' from myproject import settings from myproject.app import app from myproject.tables import metadata @pytest . fixture ( autouse = True , scope = \"session\" ) def setup_test_database (): \"\"\" Create a clean test database every time the tests are run. \"\"\" url = str ( settings . DATABASE_URL ) engine = create_engine ( url ) assert not database_exists ( url ), 'Test database already exists. Aborting tests.' create_database ( url ) # Create the test database. metadata . create_all ( engine ) # Create the tables. yield # Run the tests. drop_database ( url ) # Drop the test database. @pytest . fixture () def client (): \"\"\" Make a 'client' fixture available to test cases. \"\"\" # Our fixture is created within a context manager. This ensures that # application startup and shutdown run for every test case. # # Because we've configured the DatabaseMiddleware with `rollback_on_shutdown` # we'll get a complete rollback to the initial state after each test case runs. with TestClient ( app ) as test_client : yield test_client","title":"A full example"},{"location":"database/","text":"Starlette is not strictly tied to any particular database implementation. You can use it with an asynchronous ORM, such as GINO , or use regular non-async endpoints, and integrate with SQLAlchemy . In this documentation we'll demonstrate how to integrate against the databases package , which provides SQLAlchemy core support against a range of different database drivers. Note : Previous versions of Starlette included a built-in DatabaseMiddleware . This option is currently still available but should be considered as pending deprecation. It will be removed in a future release. The legacy documentation is available here . Here's a complete example, that includes table definitions, configuring a database.Database instance, and a couple of endpoints that interact with the database. .env DATABASE_URL = sqlite:///test.db app.py import databases import sqlalchemy from starlette.applications import Starlette from starlette.config import Config from starlette.responses import JSONResponse from starlette.routing import Route # Configuration from environment variables or '.env' file. config = Config ( '.env' ) DATABASE_URL = config ( 'DATABASE_URL' ) # Database table definitions. metadata = sqlalchemy . MetaData () notes = sqlalchemy . Table ( \"notes\" , metadata , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) database = databases . Database ( DATABASE_URL ) # Main application code. async def list_notes ( request ): query = notes . select () results = await database . fetch_all ( query ) content = [ { \"text\" : result [ \"text\" ], \"completed\" : result [ \"completed\" ] } for result in results ] return JSONResponse ( content ) async def add_note ( request ): data = await request . json () query = notes . insert () . values ( text = data [ \"text\" ], completed = data [ \"completed\" ] ) await database . execute ( query ) return JSONResponse ({ \"text\" : data [ \"text\" ], \"completed\" : data [ \"completed\" ] }) routes = [ Route ( \"/notes\" , endpoint = list_notes , methods = [ \"GET\" ]), Route ( \"/notes\" , endpoint = add_note , methods = [ \"POST\" ]), ] app = Starlette ( routes = routes , on_startup = [ database . connect ], on_shutdown = [ database . disconnect ] ) Finally, you will need to create the database tables. It is recommended to use Alembic, which we briefly go over in Migrations Queries Queries may be made with as SQLAlchemy Core queries . The following methods are supported: rows = await database.fetch_all(query) row = await database.fetch_one(query) async for row in database.iterate(query) await database.execute(query) await database.execute_many(query) Transactions Database transactions are available either as a decorator, as a context manager, or as a low-level API. Using a decorator on an endpoint: @database . transaction () async def populate_note ( request ): # This database insert occurs within a transaction. # It will be rolled back by the `RuntimeError`. query = notes . insert () . values ( text = \"you won't see me\" , completed = True ) await database . execute ( query ) raise RuntimeError () Using a context manager: async def populate_note ( request ): async with database . transaction (): # This database insert occurs within a transaction. # It will be rolled back by the `RuntimeError`. query = notes . insert () . values ( text = \"you won't see me\" , completed = True ) await request . database . execute ( query ) raise RuntimeError () Using the low-level API: async def populate_note ( request ): transaction = await database . transaction () try : # This database insert occurs within a transaction. # It will be rolled back by the `RuntimeError`. query = notes . insert () . values ( text = \"you won't see me\" , completed = True ) await database . execute ( query ) raise RuntimeError () except : transaction . rollback () raise else : transaction . commit () Test isolation There are a few things that we want to ensure when running tests against a service that uses a database. Our requirements should be: Use a separate database for testing. Create a new test database every time we run the tests. Ensure that the database state is isolated between each test case. Here's how we need to structure our application and tests in order to meet those requirements: from starlette.applications import Starlette from starlette.config import Config import databases config = Config ( \".env\" ) TESTING = config ( 'TESTING' , cast = bool , default = False ) DATABASE_URL = config ( 'DATABASE_URL' , cast = databases . DatabaseURL ) TEST_DATABASE_URL = DATABASE_URL . replace ( database = 'test_' + DATABASE_URL . database ) # Use 'force_rollback' during testing, to ensure we do not persist database changes # between each test case. if TESTING : database = databases . Database ( TEST_DATABASE_URL , force_rollback = True ) else : database = databases . Database ( DATABASE_URL ) We still need to set TESTING during a test run, and setup the test database. Assuming we're using py.test , here's how our conftest.py might look: import pytest from starlette.config import environ from starlette.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy_utils import database_exists , create_database , drop_database # This sets `os.environ`, but provides some additional protection. # If we placed it below the application import, it would raise an error # informing us that 'TESTING' had already been read from the environment. environ [ 'TESTING' ] = 'True' import app @pytest . fixture ( scope = \"session\" , autouse = True ) def create_test_database (): \"\"\" Create a clean database on every test case. For safety, we should abort if a database already exists. We use the `sqlalchemy_utils` package here for a few helpers in consistently creating and dropping the database. \"\"\" url = str ( app . TEST_DATABASE_URL ) engine = create_engine ( url ) assert not database_exists ( url ), 'Test database already exists. Aborting tests.' create_database ( url ) # Create the test database. metadata . create_all ( engine ) # Create the tables. yield # Run the tests. drop_database ( url ) # Drop the test database. @pytest . fixture () def client (): \"\"\" When using the 'client' fixture in test cases, we'll get full database rollbacks between test cases: def test_homepage(client): url = app.url_path_for('homepage') response = client.get(url) assert response.status_code == 200 \"\"\" with TestClient ( app ) as client : yield client Migrations You'll almost certainly need to be using database migrations in order to manage incremental changes to the database. For this we'd strongly recommend Alembic , which is written by the author of SQLAlchemy. $ pip install alembic $ alembic init migrations Now, you'll want to set things up so that Alembic references the configured DATABASE_URL, and uses your table metadata. In alembic.ini remove the following line: sqlalchemy.url = driver://user:pass@localhost/dbname In migrations/env.py , you need to set the 'sqlalchemy.url' configuration key, and the target_metadata variable. You'll want something like this: # The Alembic Config object. config = context . config # Configure Alembic to use our DATABASE_URL and our table definitions... import app config . set_main_option ( 'sqlalchemy.url' , str ( app . DATABASE_URL )) target_metadata = app . metadata ... Then, using our notes example above, create an initial revision: alembic revision -m \"Create notes table\" And populate the new file (within migrations/versions ) with the necessary directives: def upgrade (): op . create_table ( 'notes' , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) def downgrade (): op . drop_table ( 'notes' ) And run your first migration. Our notes app can now run! alembic upgrade head Running migrations during testing It is good practice to ensure that your test suite runs the database migrations every time it creates the test database. This will help catch any issues in your migration scripts, and will help ensure that the tests are running against a database that's in a consistent state with your live database. We can adjust the create_test_database fixture slightly: from alembic import command from alembic.config import Config import app ... @pytest . fixture ( scope = \"session\" , autouse = True ) def create_test_database (): url = str ( app . DATABASE_URL ) engine = create_engine ( url ) assert not database_exists ( url ), 'Test database already exists. Aborting tests.' create_database ( url ) # Create the test database. config = Config ( \"alembic.ini\" ) # Run the migrations. command . upgrade ( config , \"head\" ) yield # Run the tests. drop_database ( url ) # Drop the test database.","title":"Database"},{"location":"database/#queries","text":"Queries may be made with as SQLAlchemy Core queries . The following methods are supported: rows = await database.fetch_all(query) row = await database.fetch_one(query) async for row in database.iterate(query) await database.execute(query) await database.execute_many(query)","title":"Queries"},{"location":"database/#transactions","text":"Database transactions are available either as a decorator, as a context manager, or as a low-level API. Using a decorator on an endpoint: @database . transaction () async def populate_note ( request ): # This database insert occurs within a transaction. # It will be rolled back by the `RuntimeError`. query = notes . insert () . values ( text = \"you won't see me\" , completed = True ) await database . execute ( query ) raise RuntimeError () Using a context manager: async def populate_note ( request ): async with database . transaction (): # This database insert occurs within a transaction. # It will be rolled back by the `RuntimeError`. query = notes . insert () . values ( text = \"you won't see me\" , completed = True ) await request . database . execute ( query ) raise RuntimeError () Using the low-level API: async def populate_note ( request ): transaction = await database . transaction () try : # This database insert occurs within a transaction. # It will be rolled back by the `RuntimeError`. query = notes . insert () . values ( text = \"you won't see me\" , completed = True ) await database . execute ( query ) raise RuntimeError () except : transaction . rollback () raise else : transaction . commit ()","title":"Transactions"},{"location":"database/#test-isolation","text":"There are a few things that we want to ensure when running tests against a service that uses a database. Our requirements should be: Use a separate database for testing. Create a new test database every time we run the tests. Ensure that the database state is isolated between each test case. Here's how we need to structure our application and tests in order to meet those requirements: from starlette.applications import Starlette from starlette.config import Config import databases config = Config ( \".env\" ) TESTING = config ( 'TESTING' , cast = bool , default = False ) DATABASE_URL = config ( 'DATABASE_URL' , cast = databases . DatabaseURL ) TEST_DATABASE_URL = DATABASE_URL . replace ( database = 'test_' + DATABASE_URL . database ) # Use 'force_rollback' during testing, to ensure we do not persist database changes # between each test case. if TESTING : database = databases . Database ( TEST_DATABASE_URL , force_rollback = True ) else : database = databases . Database ( DATABASE_URL ) We still need to set TESTING during a test run, and setup the test database. Assuming we're using py.test , here's how our conftest.py might look: import pytest from starlette.config import environ from starlette.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy_utils import database_exists , create_database , drop_database # This sets `os.environ`, but provides some additional protection. # If we placed it below the application import, it would raise an error # informing us that 'TESTING' had already been read from the environment. environ [ 'TESTING' ] = 'True' import app @pytest . fixture ( scope = \"session\" , autouse = True ) def create_test_database (): \"\"\" Create a clean database on every test case. For safety, we should abort if a database already exists. We use the `sqlalchemy_utils` package here for a few helpers in consistently creating and dropping the database. \"\"\" url = str ( app . TEST_DATABASE_URL ) engine = create_engine ( url ) assert not database_exists ( url ), 'Test database already exists. Aborting tests.' create_database ( url ) # Create the test database. metadata . create_all ( engine ) # Create the tables. yield # Run the tests. drop_database ( url ) # Drop the test database. @pytest . fixture () def client (): \"\"\" When using the 'client' fixture in test cases, we'll get full database rollbacks between test cases: def test_homepage(client): url = app.url_path_for('homepage') response = client.get(url) assert response.status_code == 200 \"\"\" with TestClient ( app ) as client : yield client","title":"Test isolation"},{"location":"database/#migrations","text":"You'll almost certainly need to be using database migrations in order to manage incremental changes to the database. For this we'd strongly recommend Alembic , which is written by the author of SQLAlchemy. $ pip install alembic $ alembic init migrations Now, you'll want to set things up so that Alembic references the configured DATABASE_URL, and uses your table metadata. In alembic.ini remove the following line: sqlalchemy.url = driver://user:pass@localhost/dbname In migrations/env.py , you need to set the 'sqlalchemy.url' configuration key, and the target_metadata variable. You'll want something like this: # The Alembic Config object. config = context . config # Configure Alembic to use our DATABASE_URL and our table definitions... import app config . set_main_option ( 'sqlalchemy.url' , str ( app . DATABASE_URL )) target_metadata = app . metadata ... Then, using our notes example above, create an initial revision: alembic revision -m \"Create notes table\" And populate the new file (within migrations/versions ) with the necessary directives: def upgrade (): op . create_table ( 'notes' , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) def downgrade (): op . drop_table ( 'notes' ) And run your first migration. Our notes app can now run! alembic upgrade head Running migrations during testing It is good practice to ensure that your test suite runs the database migrations every time it creates the test database. This will help catch any issues in your migration scripts, and will help ensure that the tests are running against a database that's in a consistent state with your live database. We can adjust the create_test_database fixture slightly: from alembic import command from alembic.config import Config import app ... @pytest . fixture ( scope = \"session\" , autouse = True ) def create_test_database (): url = str ( app . DATABASE_URL ) engine = create_engine ( url ) assert not database_exists ( url ), 'Test database already exists. Aborting tests.' create_database ( url ) # Create the test database. config = Config ( \"alembic.ini\" ) # Run the migrations. command . upgrade ( config , \"head\" ) yield # Run the tests. drop_database ( url ) # Drop the test database.","title":"Migrations"},{"location":"endpoints/","text":"Starlette includes the classes HTTPEndpoint and WebSocketEndpoint that provide a class-based view pattern for handling HTTP method dispatching and WebSocket sessions. HTTPEndpoint The HTTPEndpoint class can be used as an ASGI application: from starlette.responses import PlainTextResponse from starlette.endpoints import HTTPEndpoint class App ( HTTPEndpoint ): async def get ( self , request ): return PlainTextResponse ( f \"Hello, world!\" ) If you're using a Starlette application instance to handle routing, you can dispatch to an HTTPEndpoint class. Make sure to dispatch to the class itself, rather than to an instance of the class: from starlette.applications import Starlette from starlette.responses import PlainTextResponse from starlette.endpoints import HTTPEndpoint from starlette.routing import Route class Homepage ( HTTPEndpoint ): async def get ( self , request ): return PlainTextResponse ( f \"Hello, world!\" ) class User ( HTTPEndpoint ): async def get ( self , request ): username = request . path_params [ 'username' ] return PlainTextResponse ( f \"Hello, { username } \" ) routes = [ Route ( \"/\" , Homepage ), Route ( \"/ {username} \" , User ) ] app = Starlette ( routes = routes ) HTTP endpoint classes will respond with \"405 Method not allowed\" responses for any request methods which do not map to a corresponding handler. WebSocketEndpoint The WebSocketEndpoint class is an ASGI application that presents a wrapper around the functionality of a WebSocket instance. The ASGI connection scope is accessible on the endpoint instance via .scope and has an attribute encoding which may optionally be set, in order to validate the expected websocket data in the on_receive method. The encoding types are: 'json' 'bytes' 'text' There are three overridable methods for handling specific ASGI websocket message types: async def on_connect(websocket, **kwargs) async def on_receive(websocket, data) async def on_disconnect(websocket, close_code) from starlette.endpoints import WebSocketEndpoint class App ( WebSocketEndpoint ): encoding = 'bytes' async def on_connect ( self , websocket ): await websocket . accept () async def on_receive ( self , websocket , data ): await websocket . send_bytes ( b \"Message: \" + data ) async def on_disconnect ( self , websocket , close_code ): pass The WebSocketEndpoint can also be used with the Starlette application class: import uvicorn from starlette.applications import Starlette from starlette.endpoints import WebSocketEndpoint , HTTPEndpoint from starlette.responses import HTMLResponse from starlette.routing import Route , WebSocketRoute html = \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" class Homepage ( HTTPEndpoint ): async def get ( self , request ): return HTMLResponse ( html ) class Echo ( WebSocketEndpoint ): encoding = \"text\" async def on_receive ( self , websocket , data ): await websocket . send_text ( f \"Message text was: { data } \" ) routes = [ Route ( \"/\" , Homepage ), WebSocketRoute ( \"/ws\" , Echo ) ] app = Starlette ( routes = routes )","title":"Endpoints"},{"location":"endpoints/#httpendpoint","text":"The HTTPEndpoint class can be used as an ASGI application: from starlette.responses import PlainTextResponse from starlette.endpoints import HTTPEndpoint class App ( HTTPEndpoint ): async def get ( self , request ): return PlainTextResponse ( f \"Hello, world!\" ) If you're using a Starlette application instance to handle routing, you can dispatch to an HTTPEndpoint class. Make sure to dispatch to the class itself, rather than to an instance of the class: from starlette.applications import Starlette from starlette.responses import PlainTextResponse from starlette.endpoints import HTTPEndpoint from starlette.routing import Route class Homepage ( HTTPEndpoint ): async def get ( self , request ): return PlainTextResponse ( f \"Hello, world!\" ) class User ( HTTPEndpoint ): async def get ( self , request ): username = request . path_params [ 'username' ] return PlainTextResponse ( f \"Hello, { username } \" ) routes = [ Route ( \"/\" , Homepage ), Route ( \"/ {username} \" , User ) ] app = Starlette ( routes = routes ) HTTP endpoint classes will respond with \"405 Method not allowed\" responses for any request methods which do not map to a corresponding handler.","title":"HTTPEndpoint"},{"location":"endpoints/#websocketendpoint","text":"The WebSocketEndpoint class is an ASGI application that presents a wrapper around the functionality of a WebSocket instance. The ASGI connection scope is accessible on the endpoint instance via .scope and has an attribute encoding which may optionally be set, in order to validate the expected websocket data in the on_receive method. The encoding types are: 'json' 'bytes' 'text' There are three overridable methods for handling specific ASGI websocket message types: async def on_connect(websocket, **kwargs) async def on_receive(websocket, data) async def on_disconnect(websocket, close_code) from starlette.endpoints import WebSocketEndpoint class App ( WebSocketEndpoint ): encoding = 'bytes' async def on_connect ( self , websocket ): await websocket . accept () async def on_receive ( self , websocket , data ): await websocket . send_bytes ( b \"Message: \" + data ) async def on_disconnect ( self , websocket , close_code ): pass The WebSocketEndpoint can also be used with the Starlette application class: import uvicorn from starlette.applications import Starlette from starlette.endpoints import WebSocketEndpoint , HTTPEndpoint from starlette.responses import HTMLResponse from starlette.routing import Route , WebSocketRoute html = \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" class Homepage ( HTTPEndpoint ): async def get ( self , request ): return HTMLResponse ( html ) class Echo ( WebSocketEndpoint ): encoding = \"text\" async def on_receive ( self , websocket , data ): await websocket . send_text ( f \"Message text was: { data } \" ) routes = [ Route ( \"/\" , Homepage ), WebSocketRoute ( \"/ws\" , Echo ) ] app = Starlette ( routes = routes )","title":"WebSocketEndpoint"},{"location":"events/","text":"Starlette applications can register multiple event handlers for dealing with code that needs to run before the application starts up, or when the application is shutting down. Registering events These event handlers can either be async coroutines, or regular synchronous functions. The event handlers should be included on the application like so: from starlette.applications import Starlette async def some_startup_task (): pass async def some_shutdown_task (): pass routes = [ ... ] app = Starlette ( routes = routes , on_startup = [ some_startup_task ], on_shutdown = [ some_shutdown_task ] ) Starlette will not start serving any incoming requests until all of the registered startup handlers have completed. The shutdown handlers will run once all connections have been closed, and any in-process background tasks have completed. A single lifespan asynccontextmanager handler can be used instead of separate startup and shutdown handlers: import contextlib import anyio from starlette.applications import Starlette @contextlib . asynccontextmanager async def lifespan ( app ): async with some_async_resource (): yield routes = [ ... ] app = Starlette ( routes = routes , lifespan = lifespan ) Consider using anyio.create_task_group() for managing asynchronious tasks. Running event handlers in tests You might want to explicitly call into your event handlers in any test setup or test teardown code. Alternatively, you can use TestClient as a context manager, to ensure that startup and shutdown events are called. from example import app from starlette.testclient import TestClient def test_homepage (): with TestClient ( app ) as client : # Application 'on_startup' handlers are called on entering the block. response = client . get ( \"/\" ) assert response . status_code == 200 # Application 'on_shutdown' handlers are called on exiting the block.","title":"Events"},{"location":"events/#registering-events","text":"These event handlers can either be async coroutines, or regular synchronous functions. The event handlers should be included on the application like so: from starlette.applications import Starlette async def some_startup_task (): pass async def some_shutdown_task (): pass routes = [ ... ] app = Starlette ( routes = routes , on_startup = [ some_startup_task ], on_shutdown = [ some_shutdown_task ] ) Starlette will not start serving any incoming requests until all of the registered startup handlers have completed. The shutdown handlers will run once all connections have been closed, and any in-process background tasks have completed. A single lifespan asynccontextmanager handler can be used instead of separate startup and shutdown handlers: import contextlib import anyio from starlette.applications import Starlette @contextlib . asynccontextmanager async def lifespan ( app ): async with some_async_resource (): yield routes = [ ... ] app = Starlette ( routes = routes , lifespan = lifespan ) Consider using anyio.create_task_group() for managing asynchronious tasks.","title":"Registering events"},{"location":"events/#running-event-handlers-in-tests","text":"You might want to explicitly call into your event handlers in any test setup or test teardown code. Alternatively, you can use TestClient as a context manager, to ensure that startup and shutdown events are called. from example import app from starlette.testclient import TestClient def test_homepage (): with TestClient ( app ) as client : # Application 'on_startup' handlers are called on entering the block. response = client . get ( \"/\" ) assert response . status_code == 200 # Application 'on_shutdown' handlers are called on exiting the block.","title":"Running event handlers in tests"},{"location":"exceptions/","text":"Starlette allows you to install custom exception handlers to deal with how you return responses when errors or handled exceptions occur. from starlette.applications import Starlette from starlette.responses import HTMLResponse HTML_404_PAGE = ... HTML_500_PAGE = ... async def not_found ( request , exc ): return HTMLResponse ( content = HTML_404_PAGE , status_code = exc . status_code ) async def server_error ( request , exc ): return HTMLResponse ( content = HTML_500_PAGE , status_code = exc . status_code ) exception_handlers = { 404 : not_found , 500 : server_error } app = Starlette ( routes = routes , exception_handlers = exception_handlers ) If debug is enabled and an error occurs, then instead of using the installed 500 handler, Starlette will respond with a traceback response. app = Starlette ( debug = True , routes = routes , exception_handlers = exception_handlers ) As well as registering handlers for specific status codes, you can also register handlers for classes of exceptions. In particular you might want to override how the built-in HTTPException class is handled. For example, to use JSON style responses: async def http_exception ( request , exc ): return JSONResponse ({ \"detail\" : exc . detail }, status_code = exc . status_code ) exception_handlers = { HTTPException : http_exception } Errors and handled exceptions It is important to differentiate between handled exceptions and errors. Handled exceptions do not represent error cases. They are coerced into appropriate HTTP responses, which are then sent through the standard middleware stack. By default the HTTPException class is used to manage any handled exceptions. Errors are any other exception that occurs within the application. These cases should bubble through the entire middleware stack as exceptions. Any error logging middleware should ensure that it re-raises the exception all the way up to the server. In order to deal with this behaviour correctly, the middleware stack of a Starlette application is configured like this: ServerErrorMiddleware - Returns 500 responses when server errors occur. Installed middleware ExceptionMiddleware - Deals with handled exceptions, and returns responses. Router Endpoints HTTPException The HTTPException class provides a base class that you can use for any handled exceptions. The ExceptionMiddleware implementation defaults to returning plain-text HTTP responses for any HTTPException . HTTPException(status_code, detail=None) You should only raise HTTPException inside routing or endpoints. Middleware classes should instead just return appropriate responses directly.","title":"Exceptions"},{"location":"exceptions/#errors-and-handled-exceptions","text":"It is important to differentiate between handled exceptions and errors. Handled exceptions do not represent error cases. They are coerced into appropriate HTTP responses, which are then sent through the standard middleware stack. By default the HTTPException class is used to manage any handled exceptions. Errors are any other exception that occurs within the application. These cases should bubble through the entire middleware stack as exceptions. Any error logging middleware should ensure that it re-raises the exception all the way up to the server. In order to deal with this behaviour correctly, the middleware stack of a Starlette application is configured like this: ServerErrorMiddleware - Returns 500 responses when server errors occur. Installed middleware ExceptionMiddleware - Deals with handled exceptions, and returns responses. Router Endpoints","title":"Errors and handled exceptions"},{"location":"exceptions/#httpexception","text":"The HTTPException class provides a base class that you can use for any handled exceptions. The ExceptionMiddleware implementation defaults to returning plain-text HTTP responses for any HTTPException . HTTPException(status_code, detail=None) You should only raise HTTPException inside routing or endpoints. Middleware classes should instead just return appropriate responses directly.","title":"HTTPException"},{"location":"graphql/","text":"Warning GraphQL support in Starlette is deprecated as of version 0.15 and will be removed in a future release. It is also incompatible with Python 3.10+. Please consider using a third-party library to provide GraphQL support. This is usually done by mounting a GraphQL ASGI application. See #619 . Some example libraries are: Ariadne tartiflette-asgi Strawberry starlette-graphene3 Starlette includes optional support for GraphQL, using the graphene library. Here's an example of integrating the support into your application. from starlette.applications import Starlette from starlette.routing import Route from starlette.graphql import GraphQLApp import graphene class Query ( graphene . ObjectType ): hello = graphene . String ( name = graphene . String ( default_value = \"stranger\" )) def resolve_hello ( self , info , name ): return \"Hello \" + name routes = [ Route ( '/' , GraphQLApp ( schema = graphene . Schema ( query = Query ))) ] app = Starlette ( routes = routes ) If you load up the page in a browser, you'll be served the GraphiQL tool, which you can use to interact with your GraphQL API. Accessing request information The current request is available in the context. class Query ( graphene . ObjectType ): user_agent = graphene . String () def resolve_user_agent ( self , info ): \"\"\" Return the User-Agent of the incoming request. \"\"\" request = info . context [ \"request\" ] return request . headers . get ( \"User-Agent\" , \"<unknown>\" ) Adding background tasks You can add background tasks to run once the response has been sent. class Query ( graphene . ObjectType ): user_agent = graphene . String () def resolve_user_agent ( self , info ): \"\"\" Return the User-Agent of the incoming request. \"\"\" user_agent = request . headers . get ( \"User-Agent\" , \"<unknown>\" ) background = info . context [ \"background\" ] background . add_task ( log_user_agent , user_agent = user_agent ) return user_agent async def log_user_agent ( user_agent ): ... Sync or Async executors If you're working with a standard ORM, then just use regular function calls for your \"resolve\" methods, and Starlette will manage running the GraphQL query within a separate thread. If you want to use an asynchronous ORM, then use \"async resolve\" methods, and make sure to setup Graphene's AsyncioExecutor using the executor argument. from graphql.execution.executors.asyncio import AsyncioExecutor from starlette.applications import Starlette from starlette.graphql import GraphQLApp from starlette.routing import Route import graphene class Query ( graphene . ObjectType ): hello = graphene . String ( name = graphene . String ( default_value = \"stranger\" )) async def resolve_hello ( self , info , name ): # We can make asynchronous network calls here. return \"Hello \" + name routes = [ # We're using `executor_class=AsyncioExecutor` here. Route ( '/' , GraphQLApp ( schema = graphene . Schema ( query = Query ), executor_class = AsyncioExecutor )) ] app = Starlette ( routes = routes )","title":"GraphQL"},{"location":"graphql/#accessing-request-information","text":"The current request is available in the context. class Query ( graphene . ObjectType ): user_agent = graphene . String () def resolve_user_agent ( self , info ): \"\"\" Return the User-Agent of the incoming request. \"\"\" request = info . context [ \"request\" ] return request . headers . get ( \"User-Agent\" , \"<unknown>\" )","title":"Accessing request information"},{"location":"graphql/#adding-background-tasks","text":"You can add background tasks to run once the response has been sent. class Query ( graphene . ObjectType ): user_agent = graphene . String () def resolve_user_agent ( self , info ): \"\"\" Return the User-Agent of the incoming request. \"\"\" user_agent = request . headers . get ( \"User-Agent\" , \"<unknown>\" ) background = info . context [ \"background\" ] background . add_task ( log_user_agent , user_agent = user_agent ) return user_agent async def log_user_agent ( user_agent ): ...","title":"Adding background tasks"},{"location":"graphql/#sync-or-async-executors","text":"If you're working with a standard ORM, then just use regular function calls for your \"resolve\" methods, and Starlette will manage running the GraphQL query within a separate thread. If you want to use an asynchronous ORM, then use \"async resolve\" methods, and make sure to setup Graphene's AsyncioExecutor using the executor argument. from graphql.execution.executors.asyncio import AsyncioExecutor from starlette.applications import Starlette from starlette.graphql import GraphQLApp from starlette.routing import Route import graphene class Query ( graphene . ObjectType ): hello = graphene . String ( name = graphene . String ( default_value = \"stranger\" )) async def resolve_hello ( self , info , name ): # We can make asynchronous network calls here. return \"Hello \" + name routes = [ # We're using `executor_class=AsyncioExecutor` here. Route ( '/' , GraphQLApp ( schema = graphene . Schema ( query = Query ), executor_class = AsyncioExecutor )) ] app = Starlette ( routes = routes )","title":"Sync or Async executors"},{"location":"middleware/","text":"Starlette includes several middleware classes for adding behavior that is applied across your entire application. These are all implemented as standard ASGI middleware classes, and can be applied either to Starlette or to any other ASGI application. The Starlette application class allows you to include the ASGI middleware in a way that ensures that it remains wrapped by the exception handler. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.httpsredirect import HTTPSRedirectMiddleware from starlette.middleware.trustedhost import TrustedHostMiddleware routes = ... # Ensure that all requests include an 'example.com' or '*.example.com' host header, # and strictly enforce https-only access. middleware = [ Middleware ( TrustedHostMiddleware , allowed_hosts = [ 'example.com' , '*.example.com' ]), Middleware ( HTTPSRedirectMiddleware ) ] app = Starlette ( routes = routes , middleware = middleware ) Every Starlette application automatically includes two pieces of middleware by default: ServerErrorMiddleware - Ensures that application exceptions may return a custom 500 page, or display an application traceback in DEBUG mode. This is always the outermost middleware layer. ExceptionMiddleware - Adds exception handlers, so that particular types of expected exception cases can be associated with handler functions. For example raising HTTPException(status_code=404) within an endpoint will end up rendering a custom 404 page. Middleware is evaluated from top-to-bottom, so the flow of execution in our example application would look like this: Middleware ServerErrorMiddleware TrustedHostMiddleware HTTPSRedirectMiddleware ExceptionMiddleware Routing Endpoint The following middleware implementations are available in the Starlette package: CORSMiddleware Adds appropriate CORS headers to outgoing responses in order to allow cross-origin requests from browsers. The default parameters used by the CORSMiddleware implementation are restrictive by default, so you'll need to explicitly enable particular origins, methods, or headers, in order for browsers to be permitted to use them in a Cross-Domain context. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.cors import CORSMiddleware routes = ... middleware = [ Middleware ( CORSMiddleware , allow_origins = [ '*' ]) ] app = Starlette ( routes = routes , middleware = middleware ) The following arguments are supported: allow_origins - A list of origins that should be permitted to make cross-origin requests. eg. ['https://example.org', 'https://www.example.org'] . You can use ['*'] to allow any origin. allow_origin_regex - A regex string to match against origins that should be permitted to make cross-origin requests. eg. 'https://.*\\.example\\.org' . allow_methods - A list of HTTP methods that should be allowed for cross-origin requests. Defaults to ['GET'] . You can use ['*'] to allow all standard methods. allow_headers - A list of HTTP request headers that should be supported for cross-origin requests. Defaults to [] . You can use ['*'] to allow all headers. The Accept , Accept-Language , Content-Language and Content-Type headers are always allowed for CORS requests. allow_credentials - Indicate that cookies should be supported for cross-origin requests. Defaults to False . expose_headers - Indicate any response headers that should be made accessible to the browser. Defaults to [] . max_age - Sets a maximum time in seconds for browsers to cache CORS responses. Defaults to 600 . The middleware responds to two particular types of HTTP request... CORS preflight requests These are any OPTIONS request with Origin and Access-Control-Request-Method headers. In this case the middleware will intercept the incoming request and respond with appropriate CORS headers, and either a 200 or 400 response for informational purposes. Simple requests Any request with an Origin header. In this case the middleware will pass the request through as normal, but will include appropriate CORS headers on the response. SessionMiddleware Adds signed cookie-based HTTP sessions. Session information is readable but not modifiable. Access or modify the session data using the request.session dictionary interface. The following arguments are supported: secret_key - Should be a random string. session_cookie - Defaults to \"session\". max_age - Session expiry time in seconds. Defaults to 2 weeks. same_site - SameSite flag prevents the browser from sending session cookie along with cross-site requests. Defaults to 'lax' . https_only - Indicate that Secure flag should be set (can be used with HTTPS only). Defaults to False . HTTPSRedirectMiddleware Enforces that all incoming requests must either be https or wss . Any incoming requests to http or ws will be redirected to the secure scheme instead. from starlette.applications import Starlette from starlette.middleware.httpsredirect import HTTPSRedirectMiddleware routes = ... middleware = [ Middleware ( HTTPSRedirectMiddleware ) ] app = Starlette ( routes = routes , middleware = middleware ) There are no configuration options for this middleware class. TrustedHostMiddleware Enforces that all incoming requests have a correctly set Host header, in order to guard against HTTP Host Header attacks. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.trustedhost import TrustedHostMiddleware routes = ... middleware = [ Middleware ( TrustedHostMiddleware , allowed_hosts = [ 'example.com' , '*.example.com' ]) ] app = Starlette ( routes = routes , middleware = middleware ) The following arguments are supported: allowed_hosts - A list of domain names that should be allowed as hostnames. Wildcard domains such as *.example.com are supported for matching subdomains. To allow any hostname either use allowed_hosts=[\"*\"] or omit the middleware. If an incoming request does not validate correctly then a 400 response will be sent. GZipMiddleware Handles GZip responses for any request that includes \"gzip\" in the Accept-Encoding header. The middleware will handle both standard and streaming responses. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.gzip import GZipMiddleware routes = ... middleware = [ Middleware ( GZipMiddleware , minimum_size = 1000 ) ] app = Starlette ( routes = routes , middleware = middleware ) The following arguments are supported: minimum_size - Do not GZip responses that are smaller than this minimum size in bytes. Defaults to 500 . BaseHTTPMiddleware An abstract class that allows you to write ASGI middleware against a request/response interface, rather than dealing with ASGI messages directly. To implement a middleware class using BaseHTTPMiddleware , you must override the async def dispatch(request, call_next) method. class CustomHeaderMiddleware ( BaseHTTPMiddleware ): async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom' ] = 'Example' return response middleware = [ Middleware ( CustomHeaderMiddleware ) ] app = Starlette ( routes = routes , middleware = middleware ) If you want to provide configuration options to the middleware class you should override the __init__ method, ensuring that the first argument is app , and any remaining arguments are optional keyword arguments. Make sure to set the app attribute on the instance if you do this. class CustomHeaderMiddleware ( BaseHTTPMiddleware ): def __init__ ( self , app , header_value = 'Example' ): super () . __init__ ( app ) self . header_value = header_value async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom' ] = self . header_value return response middleware = [ Middleware ( CustomHeaderMiddleware , header_value = 'Customized' ) ] app = Starlette ( routes = routes , middleware = middleware ) Middleware classes should not modify their state outside of the __init__ method. Instead you should keep any state local to the dispatch method, or pass it around explicitly, rather than mutating the middleware instance. Using middleware in other frameworks To wrap ASGI middleware around other ASGI applications, you should use the more general pattern of wrapping the application instance: app = TrustedHostMiddleware ( app , allowed_hosts = [ 'example.com' ]) You can do this with a Starlette application instance too, but it is preferable to use the middleware=<List of Middleware instances> style, as it will: Ensure that everything remains wrapped in a single outermost ServerErrorMiddleware . Preserves the top-level app instance. Third party middleware SentryMiddleware A middleware class for logging exceptions to Sentry . ProxyHeadersMiddleware Uvicorn includes a middleware class for determining the client IP address, when proxy servers are being used, based on the X-Forwarded-Proto and X-Forwarded-For headers. For more complex proxy configurations, you might want to adapt this middleware. TimingMiddleware A middleware class to emit timing information (cpu and wall time) for each request which passes through it. Includes examples for how to emit these timings as statsd metrics. datasette-auth-github This middleware adds authentication to any ASGI application, requiring users to sign in using their GitHub account (via OAuth ). Access can be restricted to specific users or to members of specific GitHub organizations or teams. PrometheusMiddleware A middleware class for capturing Prometheus metrics related to requests and responses, including in progress requests, timing... BugsnagMiddleware A middleware class for logging exceptions to Bugsnag . EarlyDataMiddleware Middleware and decorator for detecting and denying TLSv1.3 early data requests. AuthlibMiddleware A drop-in replacement for Starlette session middleware, using authlib's jwt module. StarletteOpentracing A middleware class that emits tracing info to OpenTracing.io compatible tracers and can be used to profile and monitor distributed applications. RateLimitMiddleware A rate limit middleware. Regular expression matches url; flexible rules; highly customizable. Very easy to use.","title":"Middleware"},{"location":"middleware/#corsmiddleware","text":"Adds appropriate CORS headers to outgoing responses in order to allow cross-origin requests from browsers. The default parameters used by the CORSMiddleware implementation are restrictive by default, so you'll need to explicitly enable particular origins, methods, or headers, in order for browsers to be permitted to use them in a Cross-Domain context. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.cors import CORSMiddleware routes = ... middleware = [ Middleware ( CORSMiddleware , allow_origins = [ '*' ]) ] app = Starlette ( routes = routes , middleware = middleware ) The following arguments are supported: allow_origins - A list of origins that should be permitted to make cross-origin requests. eg. ['https://example.org', 'https://www.example.org'] . You can use ['*'] to allow any origin. allow_origin_regex - A regex string to match against origins that should be permitted to make cross-origin requests. eg. 'https://.*\\.example\\.org' . allow_methods - A list of HTTP methods that should be allowed for cross-origin requests. Defaults to ['GET'] . You can use ['*'] to allow all standard methods. allow_headers - A list of HTTP request headers that should be supported for cross-origin requests. Defaults to [] . You can use ['*'] to allow all headers. The Accept , Accept-Language , Content-Language and Content-Type headers are always allowed for CORS requests. allow_credentials - Indicate that cookies should be supported for cross-origin requests. Defaults to False . expose_headers - Indicate any response headers that should be made accessible to the browser. Defaults to [] . max_age - Sets a maximum time in seconds for browsers to cache CORS responses. Defaults to 600 . The middleware responds to two particular types of HTTP request...","title":"CORSMiddleware"},{"location":"middleware/#cors-preflight-requests","text":"These are any OPTIONS request with Origin and Access-Control-Request-Method headers. In this case the middleware will intercept the incoming request and respond with appropriate CORS headers, and either a 200 or 400 response for informational purposes.","title":"CORS preflight requests"},{"location":"middleware/#simple-requests","text":"Any request with an Origin header. In this case the middleware will pass the request through as normal, but will include appropriate CORS headers on the response.","title":"Simple requests"},{"location":"middleware/#sessionmiddleware","text":"Adds signed cookie-based HTTP sessions. Session information is readable but not modifiable. Access or modify the session data using the request.session dictionary interface. The following arguments are supported: secret_key - Should be a random string. session_cookie - Defaults to \"session\". max_age - Session expiry time in seconds. Defaults to 2 weeks. same_site - SameSite flag prevents the browser from sending session cookie along with cross-site requests. Defaults to 'lax' . https_only - Indicate that Secure flag should be set (can be used with HTTPS only). Defaults to False .","title":"SessionMiddleware"},{"location":"middleware/#httpsredirectmiddleware","text":"Enforces that all incoming requests must either be https or wss . Any incoming requests to http or ws will be redirected to the secure scheme instead. from starlette.applications import Starlette from starlette.middleware.httpsredirect import HTTPSRedirectMiddleware routes = ... middleware = [ Middleware ( HTTPSRedirectMiddleware ) ] app = Starlette ( routes = routes , middleware = middleware ) There are no configuration options for this middleware class.","title":"HTTPSRedirectMiddleware"},{"location":"middleware/#trustedhostmiddleware","text":"Enforces that all incoming requests have a correctly set Host header, in order to guard against HTTP Host Header attacks. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.trustedhost import TrustedHostMiddleware routes = ... middleware = [ Middleware ( TrustedHostMiddleware , allowed_hosts = [ 'example.com' , '*.example.com' ]) ] app = Starlette ( routes = routes , middleware = middleware ) The following arguments are supported: allowed_hosts - A list of domain names that should be allowed as hostnames. Wildcard domains such as *.example.com are supported for matching subdomains. To allow any hostname either use allowed_hosts=[\"*\"] or omit the middleware. If an incoming request does not validate correctly then a 400 response will be sent.","title":"TrustedHostMiddleware"},{"location":"middleware/#gzipmiddleware","text":"Handles GZip responses for any request that includes \"gzip\" in the Accept-Encoding header. The middleware will handle both standard and streaming responses. from starlette.applications import Starlette from starlette.middleware import Middleware from starlette.middleware.gzip import GZipMiddleware routes = ... middleware = [ Middleware ( GZipMiddleware , minimum_size = 1000 ) ] app = Starlette ( routes = routes , middleware = middleware ) The following arguments are supported: minimum_size - Do not GZip responses that are smaller than this minimum size in bytes. Defaults to 500 .","title":"GZipMiddleware"},{"location":"middleware/#basehttpmiddleware","text":"An abstract class that allows you to write ASGI middleware against a request/response interface, rather than dealing with ASGI messages directly. To implement a middleware class using BaseHTTPMiddleware , you must override the async def dispatch(request, call_next) method. class CustomHeaderMiddleware ( BaseHTTPMiddleware ): async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom' ] = 'Example' return response middleware = [ Middleware ( CustomHeaderMiddleware ) ] app = Starlette ( routes = routes , middleware = middleware ) If you want to provide configuration options to the middleware class you should override the __init__ method, ensuring that the first argument is app , and any remaining arguments are optional keyword arguments. Make sure to set the app attribute on the instance if you do this. class CustomHeaderMiddleware ( BaseHTTPMiddleware ): def __init__ ( self , app , header_value = 'Example' ): super () . __init__ ( app ) self . header_value = header_value async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom' ] = self . header_value return response middleware = [ Middleware ( CustomHeaderMiddleware , header_value = 'Customized' ) ] app = Starlette ( routes = routes , middleware = middleware ) Middleware classes should not modify their state outside of the __init__ method. Instead you should keep any state local to the dispatch method, or pass it around explicitly, rather than mutating the middleware instance.","title":"BaseHTTPMiddleware"},{"location":"middleware/#using-middleware-in-other-frameworks","text":"To wrap ASGI middleware around other ASGI applications, you should use the more general pattern of wrapping the application instance: app = TrustedHostMiddleware ( app , allowed_hosts = [ 'example.com' ]) You can do this with a Starlette application instance too, but it is preferable to use the middleware=<List of Middleware instances> style, as it will: Ensure that everything remains wrapped in a single outermost ServerErrorMiddleware . Preserves the top-level app instance.","title":"Using middleware in other frameworks"},{"location":"middleware/#third-party-middleware","text":"","title":"Third party middleware"},{"location":"middleware/#sentrymiddleware","text":"A middleware class for logging exceptions to Sentry .","title":"SentryMiddleware"},{"location":"middleware/#proxyheadersmiddleware","text":"Uvicorn includes a middleware class for determining the client IP address, when proxy servers are being used, based on the X-Forwarded-Proto and X-Forwarded-For headers. For more complex proxy configurations, you might want to adapt this middleware.","title":"ProxyHeadersMiddleware"},{"location":"middleware/#timingmiddleware","text":"A middleware class to emit timing information (cpu and wall time) for each request which passes through it. Includes examples for how to emit these timings as statsd metrics.","title":"TimingMiddleware"},{"location":"middleware/#datasette-auth-github","text":"This middleware adds authentication to any ASGI application, requiring users to sign in using their GitHub account (via OAuth ). Access can be restricted to specific users or to members of specific GitHub organizations or teams.","title":"datasette-auth-github"},{"location":"middleware/#prometheusmiddleware","text":"A middleware class for capturing Prometheus metrics related to requests and responses, including in progress requests, timing...","title":"PrometheusMiddleware"},{"location":"middleware/#bugsnagmiddleware","text":"A middleware class for logging exceptions to Bugsnag .","title":"BugsnagMiddleware"},{"location":"middleware/#earlydatamiddleware","text":"Middleware and decorator for detecting and denying TLSv1.3 early data requests.","title":"EarlyDataMiddleware"},{"location":"middleware/#authlibmiddleware","text":"A drop-in replacement for Starlette session middleware, using authlib's jwt module.","title":"AuthlibMiddleware"},{"location":"middleware/#starletteopentracing","text":"A middleware class that emits tracing info to OpenTracing.io compatible tracers and can be used to profile and monitor distributed applications.","title":"StarletteOpentracing"},{"location":"middleware/#ratelimitmiddleware","text":"A rate limit middleware. Regular expression matches url; flexible rules; highly customizable. Very easy to use.","title":"RateLimitMiddleware"},{"location":"release-notes/","text":"0.16.0 July 19, 2021 Added Added Encode funding option #1219 Fixed starlette.websockets.WebSocket instances are now hashable and compare by identity #1039 A number of fixes related to running task groups in lifespan #1213 , #1227 Deprecated/removed The method starlette.templates.Jinja2Templates.get_env was removed #1218 The ClassVar starlette.testclient.TestClient.async_backend was removed, the backend is now configured using constructor kwargs #1211 Passing an Async Generator Function or a Generator Function to starlette.router.Router(lifespan_context=) is deprecated. You should wrap your lifespan in @contextlib.asynccontextmanager . #1227 #1110 0.15.0 June 23, 2021 This release includes major changes to the low-level asynchronous parts of Starlette. As a result, Starlette now depends on AnyIO and some minor API changes have occurred. Another significant change with this release is the deprecation of built-in GraphQL support . Added Starlette now supports Trio as an async runtime via AnyIO - #1157 . TestClient.websocket_connect() now must be used as a context manager. Initial support for Python 3.10 - #1201 . The compression level used in GZipMiddleware is now adjustable - #1128 . Fixed Several fixes to CORSMiddleware . See #1111 , #1112 , #1113 , #1199 . Improved exception messages in the case of duplicated path parameter names - #1177 . RedirectResponse now uses quote instead of quote_plus encoding for the Location header to better match the behaviour in other frameworks such as Django - #1164 . Exception causes are now preserved in more cases - #1158 . Session cookies now use the ASGI root path in the case of mounted applications - #1147 . Fixed a cache invalidation bug when static files were deleted in certain circumstances - #1023 . Improved memory usage of BaseHTTPMiddleware when handling large responses - #1012 fixed via #1157 Deprecated/removed Built-in GraphQL support via the GraphQLApp class has been deprecated and will be removed in a future release. Please see #619 . GraphQL is not supported on Python 3.10. The executor parameter to GraphQLApp was removed. Use executor_class instead. The workers parameter to WSGIMiddleware was removed. This hasn't had any effect since Starlette v0.6.3. 0.14.2 February 2, 2021 Fixed Fixed ServerErrorMiddleware compatibility with Python 3.9.1/3.8.7 when debug mode is enabled - #1132 . Fixed unclosed socket ResourceWarning s when using the TestClient with WebSocket endpoints - #1132. Improved detection of async endpoints wrapped in functools.partial on Python 3.8+ - #1106 . 0.14.1 November 9th, 2020 Removed UJSONResponse was removed (this change was intended to be included in 0.14.0). Please see the documentation for how to implement responses using custom JSON serialization - #1074 . 0.14.0 November 8th, 2020 Added Starlette now officially supports Python3.9. In StreamingResponse , allow custom async iterator such as objects from classes implementing __aiter__ . Allow usage of functools.partial async handlers in Python versions 3.6 and 3.7. Add 418 I'm A Teapot status code. Changed Create tasks from handler coroutines before sending them to asyncio.wait . Use format_exception instead of format_tb in ServerErrorMiddleware 's debug responses. Be more lenient with handler arguments when using the requires decorator. 0.13.8 Revert Queue(maxsize=1) fix for BaseHTTPMiddleware middleware classes and streaming responses. The StaticFiles constructor now allows pathlib.Path in addition to strings for its directory argument. 0.13.7 Fix high memory usage when using BaseHTTPMiddleware middleware classes and streaming responses. 0.13.6 Fix 404 errors with StaticFiles . 0.13.5 Add support for Starlette(lifespan=...) functions. More robust path-traversal check in StaticFiles app. Fix WSGI PATH_INFO encoding. RedirectResponse now accepts optional background parameter Allow path routes to contain regex meta characters Treat ASGI HTTP 'body' as an optional key. Don't use thread pooling for writing to in-memory upload files. 0.13.0 Switch to promoting application configuration on init style everywhere. This means dropping the decorator style in favour of declarative routing tables and middleware definitions. 0.12.12 Fix request.url_for() for the Mount-within-a-Mount case. 0.12.11 Fix request.url_for() when an ASGI root_path is being used. 0.12.1 Add URL.include_query_params(**kwargs) Add URL.replace_query_params(**kwargs) Add URL.remove_query_params(param_names) request.state properly persisting across middleware. Added request.scope interface. 0.12.0 Switch to ASGI 3.0. Fixes to CORS middleware. Add StaticFiles(html=True) support. Fix path quoting in redirect responses. 0.11.1 Add request.state interface, for storing arbitrary additional information. Support disabling GraphiQL with GraphQLApp(..., graphiql=False) . 0.11.0 DatabaseMiddleware is now dropped in favour of databases Templates are no longer configured on the application instance. Use templates = Jinja2Templates(directory=...) and return templates.TemplateResponse('index.html', {\"request\": request}) Schema generation is no longer attached to the application instance. Use schemas = SchemaGenerator(...) and return schemas.OpenAPIResponse(request=request) LifespanMiddleware is dropped in favor of router-based lifespan handling. Application instances now accept a routes argument, Starlette(routes=[...]) Schema generation now includes mounted routes. 0.10.6 Add Lifespan routing component. 0.10.5 Ensure templating does not strictly require jinja2 to be installed. 0.10.4 Templates are now configured independently from the application instance. templates = Jinja2Templates(directory=...) . Existing API remains in place, but is no longer documented, and will be deprecated in due course. See the template documentation for more details. 0.10.3 Move to independent databases package instead of DatabaseMiddleware . Existing API remains in place, but is no longer documented, and will be deprecated in due course. 0.10.2 Don't drop explicit port numbers on redirects from HTTPSRedirectMiddleware . 0.10.1 Add MySQL database support. Add host-based routing. 0.10.0 WebSockets now default to sending/receiving JSON over text data frames. Use .send_json(data, mode=\"binary\") and .receive_json(mode=\"binary\") for binary framing. GraphQLApp now takes an executor_class argument, which should be used in preference to the existing executor argument. Resolves an issue with async executors being instantiated before the event loop was setup. The executor argument is expected to be deprecated in the next median or major release. Authentication and the @requires decorator now support WebSocket endpoints. MultiDict and ImmutableMultiDict classes are available in uvicorn.datastructures . QueryParams is now instantiated with standard dict-style *args, **kwargs arguments. 0.9.11 Session cookies now include browser 'expires', in addition to the existing signed expiry. request.form() now returns a multi-dict interface. The query parameter multi-dict implementation now mirrors dict more correctly for the behavior of .keys() , .values() , and .items() when multiple same-key items occur. Use urlsplit throughout in favor of urlparse . 0.9.10 Support @requires(...) on class methods. Apply URL escaping to form data. Support HEAD requests automatically. Add await request.is_disconnected() . Pass operationName to GraphQL executor. 0.9.9 Add TemplateResponse . Add CommaSeparatedStrings datatype. Add BackgroundTasks for multiple tasks. Common subclass for Request and WebSocket , to eg. share session functionality. Expose remote address with request.client . 0.9.8 Add request.database.executemany . 0.9.7 Ensure that AuthenticationMiddleware handles lifespan messages correctly. 0.9.6 Add AuthenticationMiddleware , and @requires() decorator. 0.9.5 Support either str or Secret for SessionMiddleware(secret_key=...) . 0.9.4 Add config.environ . Add datastructures.Secret . Add datastructures.DatabaseURL . 0.9.3 Add config.Config(\".env\") 0.9.2 Add optional database support. Add request to GraphQL context. Hide any password component in URL.__repr__ . 0.9.1 Handle startup/shutdown errors properly. 0.9.0 TestClient can now be used as a context manager, instead of LifespanContext . Lifespan is now handled as middleware. Startup and Shutdown events are visible throughout the middleware stack. 0.8.8 Better support for third-party API schema generators. 0.8.7 Support chunked requests with TestClient. Cleanup asyncio tasks properly with WSGIMiddleware. Support using TestClient within endpoints, for service mocking. 0.8.6 Session cookies are now set on the root path. 0.8.5 Support URL convertors. Support HTTP 304 cache responses from StaticFiles . Resolve character escaping issue with form data. 0.8.4 Default to empty body on responses. 0.8.3 Add 'name' argument to @app.route() . Use 'Host' header for URL reconstruction. 0.8.2 StaticFiles StaticFiles no longer reads the file for responses to HEAD requests. 0.8.1 Templating Add a default templating configuration with Jinja2. Allows the following: app = Starlette ( template_directory = \"templates\" ) @app . route ( '/' ) async def homepage ( request ): # `url_for` is available inside the template. template = app . get_template ( 'index.html' ) content = template . render ( request = request ) return HTMLResponse ( content ) 0.8.0 Exceptions Add support for @app.exception_handler(404) . Ensure handled exceptions are not seen as errors by the middleware stack. SessionMiddleware Add max_age , and use timestamp-signed cookies. Defaults to two weeks. Cookies Ensure cookies are strictly HTTP correct. StaticFiles Check directory exists on instantiation. 0.7.4 Concurrency Add starlette.concurrency.run_in_threadpool . Now handles contextvar support. 0.7.3 Routing Add name= support to app.mount() . This allows eg: app.mount('/static', StaticFiles(directory='static'), name='static') . 0.7.2 Middleware Add support for @app.middleware(\"http\") decorator. Routing Add \"endpoint\" to ASGI scope. 0.7.1 Debug tracebacks Improve debug traceback information & styling. URL routing Support mounted URL lookups with \"path=\", eg. url_for('static', path=...) . Support nested URL lookups, eg. url_for('admin:user', username=...) . Add redirect slashes support. Add www redirect support. Background tasks Add background task support to FileResponse and StreamingResponse . 0.7.0 API Schema support Add app.schema_generator = SchemaGenerator(...) . Add app.schema property. Add OpenAPIResponse(...) . GraphQL routing Drop app.add_graphql_route(\"/\", ...) in favor of more consistent app.add_route(\"/\", GraphQLApp(...)) . 0.6.3 Routing API Support routing to methods. Ensure url_path_for works with Mount('/{some_path_params}'). Fix Router(default=) argument. Support repeated paths, like: @app.route(\"/\", methods=[\"GET\"]) , @app.route(\"/\", methods=[\"POST\"]) Use the default ThreadPoolExecutor for all sync endpoints. 0.6.2 SessionMiddleware Added support for request.session , with SessionMiddleware . 0.6.1 BaseHTTPMiddleware Added support for BaseHTTPMiddleware , which provides a standard request/response interface over a regular ASGI middleware. This means you can write ASGI middleware while still working at a request/response level, rather than handling ASGI messages directly. from starlette.applications import Starlette from starlette.middleware.base import BaseHTTPMiddleware class CustomMiddleware ( BaseHTTPMiddleware ): async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom-Header' ] = 'Example' return response app = Starlette () app . add_middleware ( CustomMiddleware ) 0.6.0 request.path_params The biggest change in 0.6 is that endpoint signatures are no longer: async def func ( request : Request , ** kwargs ) -> Response Instead we just use: async def func ( request : Request ) -> Response The path parameters are available on the request as request.path_params . This is different to most Python webframeworks, but I think it actually ends up being much more nicely consistent all the way through. request.url_for() Request and WebSocketSession now support URL reversing with request.url_for(name, **path_params) . This method returns a fully qualified URL instance. The URL instance is a string-like object. app.url_path_for() Applications now support URL path reversing with app.url_path_for(name, **path_params) . This method returns a URL instance with the path and scheme set. The URL instance is a string-like object, and will return only the path if coerced to a string. app.routes Applications now support a .routes parameter, which returns a list of [Route|WebSocketRoute|Mount] . Route, WebSocketRoute, Mount The low level components to Router now match the @app.route() , @app.websocket_route() , and app.mount() signatures.","title":"Release Notes"},{"location":"release-notes/#0160","text":"July 19, 2021","title":"0.16.0"},{"location":"release-notes/#added","text":"Added Encode funding option #1219","title":"Added"},{"location":"release-notes/#fixed","text":"starlette.websockets.WebSocket instances are now hashable and compare by identity #1039 A number of fixes related to running task groups in lifespan #1213 , #1227","title":"Fixed"},{"location":"release-notes/#deprecatedremoved","text":"The method starlette.templates.Jinja2Templates.get_env was removed #1218 The ClassVar starlette.testclient.TestClient.async_backend was removed, the backend is now configured using constructor kwargs #1211 Passing an Async Generator Function or a Generator Function to starlette.router.Router(lifespan_context=) is deprecated. You should wrap your lifespan in @contextlib.asynccontextmanager . #1227 #1110","title":"Deprecated/removed"},{"location":"release-notes/#0150","text":"June 23, 2021 This release includes major changes to the low-level asynchronous parts of Starlette. As a result, Starlette now depends on AnyIO and some minor API changes have occurred. Another significant change with this release is the deprecation of built-in GraphQL support .","title":"0.15.0"},{"location":"release-notes/#added_1","text":"Starlette now supports Trio as an async runtime via AnyIO - #1157 . TestClient.websocket_connect() now must be used as a context manager. Initial support for Python 3.10 - #1201 . The compression level used in GZipMiddleware is now adjustable - #1128 .","title":"Added"},{"location":"release-notes/#fixed_1","text":"Several fixes to CORSMiddleware . See #1111 , #1112 , #1113 , #1199 . Improved exception messages in the case of duplicated path parameter names - #1177 . RedirectResponse now uses quote instead of quote_plus encoding for the Location header to better match the behaviour in other frameworks such as Django - #1164 . Exception causes are now preserved in more cases - #1158 . Session cookies now use the ASGI root path in the case of mounted applications - #1147 . Fixed a cache invalidation bug when static files were deleted in certain circumstances - #1023 . Improved memory usage of BaseHTTPMiddleware when handling large responses - #1012 fixed via #1157","title":"Fixed"},{"location":"release-notes/#deprecatedremoved_1","text":"Built-in GraphQL support via the GraphQLApp class has been deprecated and will be removed in a future release. Please see #619 . GraphQL is not supported on Python 3.10. The executor parameter to GraphQLApp was removed. Use executor_class instead. The workers parameter to WSGIMiddleware was removed. This hasn't had any effect since Starlette v0.6.3.","title":"Deprecated/removed"},{"location":"release-notes/#0142","text":"February 2, 2021","title":"0.14.2"},{"location":"release-notes/#fixed_2","text":"Fixed ServerErrorMiddleware compatibility with Python 3.9.1/3.8.7 when debug mode is enabled - #1132 . Fixed unclosed socket ResourceWarning s when using the TestClient with WebSocket endpoints - #1132. Improved detection of async endpoints wrapped in functools.partial on Python 3.8+ - #1106 .","title":"Fixed"},{"location":"release-notes/#0141","text":"November 9th, 2020","title":"0.14.1"},{"location":"release-notes/#removed","text":"UJSONResponse was removed (this change was intended to be included in 0.14.0). Please see the documentation for how to implement responses using custom JSON serialization - #1074 .","title":"Removed"},{"location":"release-notes/#0140","text":"November 8th, 2020","title":"0.14.0"},{"location":"release-notes/#added_2","text":"Starlette now officially supports Python3.9. In StreamingResponse , allow custom async iterator such as objects from classes implementing __aiter__ . Allow usage of functools.partial async handlers in Python versions 3.6 and 3.7. Add 418 I'm A Teapot status code.","title":"Added"},{"location":"release-notes/#changed","text":"Create tasks from handler coroutines before sending them to asyncio.wait . Use format_exception instead of format_tb in ServerErrorMiddleware 's debug responses. Be more lenient with handler arguments when using the requires decorator.","title":"Changed"},{"location":"release-notes/#0138","text":"Revert Queue(maxsize=1) fix for BaseHTTPMiddleware middleware classes and streaming responses. The StaticFiles constructor now allows pathlib.Path in addition to strings for its directory argument.","title":"0.13.8"},{"location":"release-notes/#0137","text":"Fix high memory usage when using BaseHTTPMiddleware middleware classes and streaming responses.","title":"0.13.7"},{"location":"release-notes/#0136","text":"Fix 404 errors with StaticFiles .","title":"0.13.6"},{"location":"release-notes/#0135","text":"Add support for Starlette(lifespan=...) functions. More robust path-traversal check in StaticFiles app. Fix WSGI PATH_INFO encoding. RedirectResponse now accepts optional background parameter Allow path routes to contain regex meta characters Treat ASGI HTTP 'body' as an optional key. Don't use thread pooling for writing to in-memory upload files.","title":"0.13.5"},{"location":"release-notes/#0130","text":"Switch to promoting application configuration on init style everywhere. This means dropping the decorator style in favour of declarative routing tables and middleware definitions.","title":"0.13.0"},{"location":"release-notes/#01212","text":"Fix request.url_for() for the Mount-within-a-Mount case.","title":"0.12.12"},{"location":"release-notes/#01211","text":"Fix request.url_for() when an ASGI root_path is being used.","title":"0.12.11"},{"location":"release-notes/#0121","text":"Add URL.include_query_params(**kwargs) Add URL.replace_query_params(**kwargs) Add URL.remove_query_params(param_names) request.state properly persisting across middleware. Added request.scope interface.","title":"0.12.1"},{"location":"release-notes/#0120","text":"Switch to ASGI 3.0. Fixes to CORS middleware. Add StaticFiles(html=True) support. Fix path quoting in redirect responses.","title":"0.12.0"},{"location":"release-notes/#0111","text":"Add request.state interface, for storing arbitrary additional information. Support disabling GraphiQL with GraphQLApp(..., graphiql=False) .","title":"0.11.1"},{"location":"release-notes/#0110","text":"DatabaseMiddleware is now dropped in favour of databases Templates are no longer configured on the application instance. Use templates = Jinja2Templates(directory=...) and return templates.TemplateResponse('index.html', {\"request\": request}) Schema generation is no longer attached to the application instance. Use schemas = SchemaGenerator(...) and return schemas.OpenAPIResponse(request=request) LifespanMiddleware is dropped in favor of router-based lifespan handling. Application instances now accept a routes argument, Starlette(routes=[...]) Schema generation now includes mounted routes.","title":"0.11.0"},{"location":"release-notes/#0106","text":"Add Lifespan routing component.","title":"0.10.6"},{"location":"release-notes/#0105","text":"Ensure templating does not strictly require jinja2 to be installed.","title":"0.10.5"},{"location":"release-notes/#0104","text":"Templates are now configured independently from the application instance. templates = Jinja2Templates(directory=...) . Existing API remains in place, but is no longer documented, and will be deprecated in due course. See the template documentation for more details.","title":"0.10.4"},{"location":"release-notes/#0103","text":"Move to independent databases package instead of DatabaseMiddleware . Existing API remains in place, but is no longer documented, and will be deprecated in due course.","title":"0.10.3"},{"location":"release-notes/#0102","text":"Don't drop explicit port numbers on redirects from HTTPSRedirectMiddleware .","title":"0.10.2"},{"location":"release-notes/#0101","text":"Add MySQL database support. Add host-based routing.","title":"0.10.1"},{"location":"release-notes/#0100","text":"WebSockets now default to sending/receiving JSON over text data frames. Use .send_json(data, mode=\"binary\") and .receive_json(mode=\"binary\") for binary framing. GraphQLApp now takes an executor_class argument, which should be used in preference to the existing executor argument. Resolves an issue with async executors being instantiated before the event loop was setup. The executor argument is expected to be deprecated in the next median or major release. Authentication and the @requires decorator now support WebSocket endpoints. MultiDict and ImmutableMultiDict classes are available in uvicorn.datastructures . QueryParams is now instantiated with standard dict-style *args, **kwargs arguments.","title":"0.10.0"},{"location":"release-notes/#0911","text":"Session cookies now include browser 'expires', in addition to the existing signed expiry. request.form() now returns a multi-dict interface. The query parameter multi-dict implementation now mirrors dict more correctly for the behavior of .keys() , .values() , and .items() when multiple same-key items occur. Use urlsplit throughout in favor of urlparse .","title":"0.9.11"},{"location":"release-notes/#0910","text":"Support @requires(...) on class methods. Apply URL escaping to form data. Support HEAD requests automatically. Add await request.is_disconnected() . Pass operationName to GraphQL executor.","title":"0.9.10"},{"location":"release-notes/#099","text":"Add TemplateResponse . Add CommaSeparatedStrings datatype. Add BackgroundTasks for multiple tasks. Common subclass for Request and WebSocket , to eg. share session functionality. Expose remote address with request.client .","title":"0.9.9"},{"location":"release-notes/#098","text":"Add request.database.executemany .","title":"0.9.8"},{"location":"release-notes/#097","text":"Ensure that AuthenticationMiddleware handles lifespan messages correctly.","title":"0.9.7"},{"location":"release-notes/#096","text":"Add AuthenticationMiddleware , and @requires() decorator.","title":"0.9.6"},{"location":"release-notes/#095","text":"Support either str or Secret for SessionMiddleware(secret_key=...) .","title":"0.9.5"},{"location":"release-notes/#094","text":"Add config.environ . Add datastructures.Secret . Add datastructures.DatabaseURL .","title":"0.9.4"},{"location":"release-notes/#093","text":"Add config.Config(\".env\")","title":"0.9.3"},{"location":"release-notes/#092","text":"Add optional database support. Add request to GraphQL context. Hide any password component in URL.__repr__ .","title":"0.9.2"},{"location":"release-notes/#091","text":"Handle startup/shutdown errors properly.","title":"0.9.1"},{"location":"release-notes/#090","text":"TestClient can now be used as a context manager, instead of LifespanContext . Lifespan is now handled as middleware. Startup and Shutdown events are visible throughout the middleware stack.","title":"0.9.0"},{"location":"release-notes/#088","text":"Better support for third-party API schema generators.","title":"0.8.8"},{"location":"release-notes/#087","text":"Support chunked requests with TestClient. Cleanup asyncio tasks properly with WSGIMiddleware. Support using TestClient within endpoints, for service mocking.","title":"0.8.7"},{"location":"release-notes/#086","text":"Session cookies are now set on the root path.","title":"0.8.6"},{"location":"release-notes/#085","text":"Support URL convertors. Support HTTP 304 cache responses from StaticFiles . Resolve character escaping issue with form data.","title":"0.8.5"},{"location":"release-notes/#084","text":"Default to empty body on responses.","title":"0.8.4"},{"location":"release-notes/#083","text":"Add 'name' argument to @app.route() . Use 'Host' header for URL reconstruction.","title":"0.8.3"},{"location":"release-notes/#082","text":"","title":"0.8.2"},{"location":"release-notes/#staticfiles","text":"StaticFiles no longer reads the file for responses to HEAD requests.","title":"StaticFiles"},{"location":"release-notes/#081","text":"","title":"0.8.1"},{"location":"release-notes/#templating","text":"Add a default templating configuration with Jinja2. Allows the following: app = Starlette ( template_directory = \"templates\" ) @app . route ( '/' ) async def homepage ( request ): # `url_for` is available inside the template. template = app . get_template ( 'index.html' ) content = template . render ( request = request ) return HTMLResponse ( content )","title":"Templating"},{"location":"release-notes/#080","text":"","title":"0.8.0"},{"location":"release-notes/#exceptions","text":"Add support for @app.exception_handler(404) . Ensure handled exceptions are not seen as errors by the middleware stack.","title":"Exceptions"},{"location":"release-notes/#sessionmiddleware","text":"Add max_age , and use timestamp-signed cookies. Defaults to two weeks.","title":"SessionMiddleware"},{"location":"release-notes/#cookies","text":"Ensure cookies are strictly HTTP correct.","title":"Cookies"},{"location":"release-notes/#staticfiles_1","text":"Check directory exists on instantiation.","title":"StaticFiles"},{"location":"release-notes/#074","text":"","title":"0.7.4"},{"location":"release-notes/#concurrency","text":"Add starlette.concurrency.run_in_threadpool . Now handles contextvar support.","title":"Concurrency"},{"location":"release-notes/#073","text":"","title":"0.7.3"},{"location":"release-notes/#routing","text":"Add name= support to app.mount() . This allows eg: app.mount('/static', StaticFiles(directory='static'), name='static') .","title":"Routing"},{"location":"release-notes/#072","text":"","title":"0.7.2"},{"location":"release-notes/#middleware","text":"Add support for @app.middleware(\"http\") decorator.","title":"Middleware"},{"location":"release-notes/#routing_1","text":"Add \"endpoint\" to ASGI scope.","title":"Routing"},{"location":"release-notes/#071","text":"","title":"0.7.1"},{"location":"release-notes/#debug-tracebacks","text":"Improve debug traceback information & styling.","title":"Debug tracebacks"},{"location":"release-notes/#url-routing","text":"Support mounted URL lookups with \"path=\", eg. url_for('static', path=...) . Support nested URL lookups, eg. url_for('admin:user', username=...) . Add redirect slashes support. Add www redirect support.","title":"URL routing"},{"location":"release-notes/#background-tasks","text":"Add background task support to FileResponse and StreamingResponse .","title":"Background tasks"},{"location":"release-notes/#070","text":"","title":"0.7.0"},{"location":"release-notes/#api-schema-support","text":"Add app.schema_generator = SchemaGenerator(...) . Add app.schema property. Add OpenAPIResponse(...) .","title":"API Schema support"},{"location":"release-notes/#graphql-routing","text":"Drop app.add_graphql_route(\"/\", ...) in favor of more consistent app.add_route(\"/\", GraphQLApp(...)) .","title":"GraphQL routing"},{"location":"release-notes/#063","text":"","title":"0.6.3"},{"location":"release-notes/#routing-api","text":"Support routing to methods. Ensure url_path_for works with Mount('/{some_path_params}'). Fix Router(default=) argument. Support repeated paths, like: @app.route(\"/\", methods=[\"GET\"]) , @app.route(\"/\", methods=[\"POST\"]) Use the default ThreadPoolExecutor for all sync endpoints.","title":"Routing API"},{"location":"release-notes/#062","text":"","title":"0.6.2"},{"location":"release-notes/#sessionmiddleware_1","text":"Added support for request.session , with SessionMiddleware .","title":"SessionMiddleware"},{"location":"release-notes/#061","text":"","title":"0.6.1"},{"location":"release-notes/#basehttpmiddleware","text":"Added support for BaseHTTPMiddleware , which provides a standard request/response interface over a regular ASGI middleware. This means you can write ASGI middleware while still working at a request/response level, rather than handling ASGI messages directly. from starlette.applications import Starlette from starlette.middleware.base import BaseHTTPMiddleware class CustomMiddleware ( BaseHTTPMiddleware ): async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom-Header' ] = 'Example' return response app = Starlette () app . add_middleware ( CustomMiddleware )","title":"BaseHTTPMiddleware"},{"location":"release-notes/#060","text":"","title":"0.6.0"},{"location":"release-notes/#requestpath_params","text":"The biggest change in 0.6 is that endpoint signatures are no longer: async def func ( request : Request , ** kwargs ) -> Response Instead we just use: async def func ( request : Request ) -> Response The path parameters are available on the request as request.path_params . This is different to most Python webframeworks, but I think it actually ends up being much more nicely consistent all the way through.","title":"request.path_params"},{"location":"release-notes/#requesturl_for","text":"Request and WebSocketSession now support URL reversing with request.url_for(name, **path_params) . This method returns a fully qualified URL instance. The URL instance is a string-like object.","title":"request.url_for()"},{"location":"release-notes/#appurl_path_for","text":"Applications now support URL path reversing with app.url_path_for(name, **path_params) . This method returns a URL instance with the path and scheme set. The URL instance is a string-like object, and will return only the path if coerced to a string.","title":"app.url_path_for()"},{"location":"release-notes/#approutes","text":"Applications now support a .routes parameter, which returns a list of [Route|WebSocketRoute|Mount] .","title":"app.routes"},{"location":"release-notes/#route-websocketroute-mount","text":"The low level components to Router now match the @app.route() , @app.websocket_route() , and app.mount() signatures.","title":"Route, WebSocketRoute, Mount"},{"location":"requests/","text":"Starlette includes a Request class that gives you a nicer interface onto the incoming request, rather than accessing the ASGI scope and receive channel directly. Request Signature: Request(scope, receive=None) from starlette.requests import Request from starlette.responses import Response async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' request = Request ( scope , receive ) content = ' %s %s ' % ( request . method , request . url . path ) response = Response ( content , media_type = 'text/plain' ) await response ( scope , receive , send ) Requests present a mapping interface, so you can use them in the same way as a scope . For instance: request['path'] will return the ASGI path. If you don't need to access the request body you can instantiate a request without providing an argument to receive . Method The request method is accessed as request.method . URL The request URL is accessed as request.url . The property is a string-like object that exposes all the components that can be parsed out of the URL. For example: request.url.path , request.url.port , request.url.scheme . Headers Headers are exposed as an immutable, case-insensitive, multi-dict. For example: request.headers['content-type'] Query Parameters Query parameters are exposed as an immutable multi-dict. For example: request.query_params['search'] Path Parameters Router path parameters are exposed as a dictionary interface. For example: request.path_params['username'] Client Address The client's remote address is exposed as a named two-tuple request.client . Either item in the tuple may be None . The hostname or IP address: request.client.host The port number from which the client is connecting: request.client.port Cookies Cookies are exposed as a regular dictionary interface. For example: request.cookies.get('mycookie') Cookies are ignored in case of an invalid cookie. (RFC2109) Body There are a few different interfaces for returning the body of the request: The request body as bytes: await request.body() The request body, parsed as form data or multipart: await request.form() The request body, parsed as JSON: await request.json() You can also access the request body as a stream, using the async for syntax: from starlette.requests import Request from starlette.responses import Response async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' request = Request ( scope , receive ) body = b '' async for chunk in request . stream (): body += chunk response = Response ( body , media_type = 'text/plain' ) await response ( scope , receive , send ) If you access .stream() then the byte chunks are provided without storing the entire body to memory. Any subsequent calls to .body() , .form() , or .json() will raise an error. In some cases such as long-polling, or streaming responses you might need to determine if the client has dropped the connection. You can determine this state with disconnected = await request.is_disconnected() . Request Files Request files are normally sent as multipart form data ( multipart/form-data ). When you call await request.form() you receive a starlette.datastructures.FormData which is an immutable multidict, containing both file uploads and text input. File upload items are represented as instances of starlette.datastructures.UploadFile . UploadFile has the following attributes: filename : A str with the original file name that was uploaded (e.g. myimage.jpg ). content_type : A str with the content type (MIME type / media type) (e.g. image/jpeg ). file : A SpooledTemporaryFile (a file-like object). This is the actual Python file that you can pass directly to other functions or libraries that expect a \"file-like\" object. UploadFile has the following async methods. They all call the corresponding file methods underneath (using the internal SpooledTemporaryFile ). async write(data) : Writes data ( str or bytes ) to the file. async read(size) : Reads size ( int ) bytes/characters of the file. async seek(offset) : Goes to the byte position offset ( int ) in the file. E.g., await myfile.seek(0) would go to the start of the file. async close() : Closes the file. As all these methods are async methods, you need to \"await\" them. For example, you can get the file name and the contents with: form = await request . form () filename = form [ \"upload_file\" ] . filename contents = await form [ \"upload_file\" ] . read () Application The originating Starlette application can be accessed via request.app . Other state If you want to store additional information on the request you can do so using request.state . For example: request.state.time_started = time.time()","title":"Requests"},{"location":"requests/#request","text":"Signature: Request(scope, receive=None) from starlette.requests import Request from starlette.responses import Response async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' request = Request ( scope , receive ) content = ' %s %s ' % ( request . method , request . url . path ) response = Response ( content , media_type = 'text/plain' ) await response ( scope , receive , send ) Requests present a mapping interface, so you can use them in the same way as a scope . For instance: request['path'] will return the ASGI path. If you don't need to access the request body you can instantiate a request without providing an argument to receive .","title":"Request"},{"location":"requests/#method","text":"The request method is accessed as request.method .","title":"Method"},{"location":"requests/#url","text":"The request URL is accessed as request.url . The property is a string-like object that exposes all the components that can be parsed out of the URL. For example: request.url.path , request.url.port , request.url.scheme .","title":"URL"},{"location":"requests/#headers","text":"Headers are exposed as an immutable, case-insensitive, multi-dict. For example: request.headers['content-type']","title":"Headers"},{"location":"requests/#query-parameters","text":"Query parameters are exposed as an immutable multi-dict. For example: request.query_params['search']","title":"Query Parameters"},{"location":"requests/#path-parameters","text":"Router path parameters are exposed as a dictionary interface. For example: request.path_params['username']","title":"Path Parameters"},{"location":"requests/#client-address","text":"The client's remote address is exposed as a named two-tuple request.client . Either item in the tuple may be None . The hostname or IP address: request.client.host The port number from which the client is connecting: request.client.port","title":"Client Address"},{"location":"requests/#cookies","text":"Cookies are exposed as a regular dictionary interface. For example: request.cookies.get('mycookie') Cookies are ignored in case of an invalid cookie. (RFC2109)","title":"Cookies"},{"location":"requests/#body","text":"There are a few different interfaces for returning the body of the request: The request body as bytes: await request.body() The request body, parsed as form data or multipart: await request.form() The request body, parsed as JSON: await request.json() You can also access the request body as a stream, using the async for syntax: from starlette.requests import Request from starlette.responses import Response async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' request = Request ( scope , receive ) body = b '' async for chunk in request . stream (): body += chunk response = Response ( body , media_type = 'text/plain' ) await response ( scope , receive , send ) If you access .stream() then the byte chunks are provided without storing the entire body to memory. Any subsequent calls to .body() , .form() , or .json() will raise an error. In some cases such as long-polling, or streaming responses you might need to determine if the client has dropped the connection. You can determine this state with disconnected = await request.is_disconnected() .","title":"Body"},{"location":"requests/#request-files","text":"Request files are normally sent as multipart form data ( multipart/form-data ). When you call await request.form() you receive a starlette.datastructures.FormData which is an immutable multidict, containing both file uploads and text input. File upload items are represented as instances of starlette.datastructures.UploadFile . UploadFile has the following attributes: filename : A str with the original file name that was uploaded (e.g. myimage.jpg ). content_type : A str with the content type (MIME type / media type) (e.g. image/jpeg ). file : A SpooledTemporaryFile (a file-like object). This is the actual Python file that you can pass directly to other functions or libraries that expect a \"file-like\" object. UploadFile has the following async methods. They all call the corresponding file methods underneath (using the internal SpooledTemporaryFile ). async write(data) : Writes data ( str or bytes ) to the file. async read(size) : Reads size ( int ) bytes/characters of the file. async seek(offset) : Goes to the byte position offset ( int ) in the file. E.g., await myfile.seek(0) would go to the start of the file. async close() : Closes the file. As all these methods are async methods, you need to \"await\" them. For example, you can get the file name and the contents with: form = await request . form () filename = form [ \"upload_file\" ] . filename contents = await form [ \"upload_file\" ] . read ()","title":"Request Files"},{"location":"requests/#application","text":"The originating Starlette application can be accessed via request.app .","title":"Application"},{"location":"requests/#other-state","text":"If you want to store additional information on the request you can do so using request.state . For example: request.state.time_started = time.time()","title":"Other state"},{"location":"responses/","text":"Starlette includes a few response classes that handle sending back the appropriate ASGI messages on the send channel. Response Signature: Response(content, status_code=200, headers=None, media_type=None) content - A string or bytestring. status_code - An integer HTTP status code. headers - A dictionary of strings. media_type - A string giving the media type. eg. \"text/html\" Starlette will automatically include a Content-Length header. It will also include a Content-Type header, based on the media_type and appending a charset for text types. Once you've instantiated a response, you can send it by calling it as an ASGI application instance. from starlette.responses import Response async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = Response ( 'Hello, world!' , media_type = 'text/plain' ) await response ( scope , receive , send ) Set Cookie Starlette provides a set_cookie method to allow you to set cookies on the response object. Signature: Response.set_cookie(key, value, max_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\") key - A string that will be the cookie's key. value - A string that will be the cookie's value. max_age - An integer that defines the lifetime of the cookie in seconds. A negative integer or a value of 0 will discard the cookie immediately. Optional expires - An integer that defines the number of seconds until the cookie expires. Optional path - A string that specifies the subset of routes to which the cookie will apply. Optional domain - A string that specifies the domain for which the cookie is valid. Optional secure - A bool indicating that the cookie will only be sent to the server if request is made using SSL and the HTTPS protocol. Optional httponly - A bool indicating that the cookie cannot be accessed via JavaScript through Document.cookie property, the XMLHttpRequest or Request APIs. Optional samesite - A string that specifies the samesite strategy for the cookie. Valid values are 'lax' , 'strict' and 'none' . Defaults to 'lax' . Optional Delete Cookie Conversly, Starlette also provides a delete_cookie method to manually expire a set cookie. Signature: Response.delete_cookie(key, path='/', domain=None) HTMLResponse Takes some text or bytes and returns an HTML response. from starlette.responses import HTMLResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = HTMLResponse ( '<html><body><h1>Hello, world!</h1></body></html>' ) await response ( scope , receive , send ) PlainTextResponse Takes some text or bytes and returns a plain text response. from starlette.responses import PlainTextResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = PlainTextResponse ( 'Hello, world!' ) await response ( scope , receive , send ) JSONResponse Takes some data and returns an application/json encoded response. from starlette.responses import JSONResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = JSONResponse ({ 'hello' : 'world' }) await response ( scope , receive , send ) Custom JSON serialization If you need fine-grained control over JSON serialization, you can subclass JSONResponse and override the render method. For example, if you wanted to use a third-party JSON library such as orjson : from typing import Any import orjson from starlette.responses import JSONResponse class OrjsonResponse ( JSONResponse ): def render ( self , content : Any ) -> bytes : return orjson . dumps ( content ) In general you probably want to stick with JSONResponse by default unless you are micro-optimising a particular endpoint or need to serialize non-standard object types. RedirectResponse Returns an HTTP redirect. Uses a 307 status code by default. from starlette.responses import PlainTextResponse , RedirectResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' if scope [ 'path' ] != '/' : response = RedirectResponse ( url = '/' ) else : response = PlainTextResponse ( 'Hello, world!' ) await response ( scope , receive , send ) StreamingResponse Takes an async generator or a normal generator/iterator and streams the response body. from starlette.responses import StreamingResponse import asyncio async def slow_numbers ( minimum , maximum ): yield ( '<html><body><ul>' ) for number in range ( minimum , maximum + 1 ): yield '<li> %d </li>' % number await asyncio . sleep ( 0.5 ) yield ( '</ul></body></html>' ) async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' generator = slow_numbers ( 1 , 10 ) response = StreamingResponse ( generator , media_type = 'text/html' ) await response ( scope , receive , send ) Have in mind that file-like objects (like those created by open() ) are normal iterators. So, you can return them directly in a StreamingResponse . FileResponse Asynchronously streams a file as the response. Takes a different set of arguments to instantiate than the other response types: path - The filepath to the file to stream. headers - Any custom headers to include, as a dictionary. media_type - A string giving the media type. If unset, the filename or path will be used to infer a media type. filename - If set, this will be included in the response Content-Disposition . File responses will include appropriate Content-Length , Last-Modified and ETag headers. from starlette.responses import FileResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = FileResponse ( 'statics/favicon.ico' ) await response ( scope , receive , send ) Third party middleware SSEResponse(EventSourceResponse) Server Sent Response implements the ServerSentEvent Protocol: https://www.w3.org/TR/2009/WD-eventsource-20090421. It enables event streaming from the server to the client without the complexity of websockets.","title":"Responses"},{"location":"responses/#response","text":"Signature: Response(content, status_code=200, headers=None, media_type=None) content - A string or bytestring. status_code - An integer HTTP status code. headers - A dictionary of strings. media_type - A string giving the media type. eg. \"text/html\" Starlette will automatically include a Content-Length header. It will also include a Content-Type header, based on the media_type and appending a charset for text types. Once you've instantiated a response, you can send it by calling it as an ASGI application instance. from starlette.responses import Response async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = Response ( 'Hello, world!' , media_type = 'text/plain' ) await response ( scope , receive , send )","title":"Response"},{"location":"responses/#set-cookie","text":"Starlette provides a set_cookie method to allow you to set cookies on the response object. Signature: Response.set_cookie(key, value, max_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\") key - A string that will be the cookie's key. value - A string that will be the cookie's value. max_age - An integer that defines the lifetime of the cookie in seconds. A negative integer or a value of 0 will discard the cookie immediately. Optional expires - An integer that defines the number of seconds until the cookie expires. Optional path - A string that specifies the subset of routes to which the cookie will apply. Optional domain - A string that specifies the domain for which the cookie is valid. Optional secure - A bool indicating that the cookie will only be sent to the server if request is made using SSL and the HTTPS protocol. Optional httponly - A bool indicating that the cookie cannot be accessed via JavaScript through Document.cookie property, the XMLHttpRequest or Request APIs. Optional samesite - A string that specifies the samesite strategy for the cookie. Valid values are 'lax' , 'strict' and 'none' . Defaults to 'lax' . Optional","title":"Set Cookie"},{"location":"responses/#delete-cookie","text":"Conversly, Starlette also provides a delete_cookie method to manually expire a set cookie. Signature: Response.delete_cookie(key, path='/', domain=None)","title":"Delete Cookie"},{"location":"responses/#htmlresponse","text":"Takes some text or bytes and returns an HTML response. from starlette.responses import HTMLResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = HTMLResponse ( '<html><body><h1>Hello, world!</h1></body></html>' ) await response ( scope , receive , send )","title":"HTMLResponse"},{"location":"responses/#plaintextresponse","text":"Takes some text or bytes and returns a plain text response. from starlette.responses import PlainTextResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = PlainTextResponse ( 'Hello, world!' ) await response ( scope , receive , send )","title":"PlainTextResponse"},{"location":"responses/#jsonresponse","text":"Takes some data and returns an application/json encoded response. from starlette.responses import JSONResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = JSONResponse ({ 'hello' : 'world' }) await response ( scope , receive , send )","title":"JSONResponse"},{"location":"responses/#custom-json-serialization","text":"If you need fine-grained control over JSON serialization, you can subclass JSONResponse and override the render method. For example, if you wanted to use a third-party JSON library such as orjson : from typing import Any import orjson from starlette.responses import JSONResponse class OrjsonResponse ( JSONResponse ): def render ( self , content : Any ) -> bytes : return orjson . dumps ( content ) In general you probably want to stick with JSONResponse by default unless you are micro-optimising a particular endpoint or need to serialize non-standard object types.","title":"Custom JSON serialization"},{"location":"responses/#redirectresponse","text":"Returns an HTTP redirect. Uses a 307 status code by default. from starlette.responses import PlainTextResponse , RedirectResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' if scope [ 'path' ] != '/' : response = RedirectResponse ( url = '/' ) else : response = PlainTextResponse ( 'Hello, world!' ) await response ( scope , receive , send )","title":"RedirectResponse"},{"location":"responses/#streamingresponse","text":"Takes an async generator or a normal generator/iterator and streams the response body. from starlette.responses import StreamingResponse import asyncio async def slow_numbers ( minimum , maximum ): yield ( '<html><body><ul>' ) for number in range ( minimum , maximum + 1 ): yield '<li> %d </li>' % number await asyncio . sleep ( 0.5 ) yield ( '</ul></body></html>' ) async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' generator = slow_numbers ( 1 , 10 ) response = StreamingResponse ( generator , media_type = 'text/html' ) await response ( scope , receive , send ) Have in mind that file-like objects (like those created by open() ) are normal iterators. So, you can return them directly in a StreamingResponse .","title":"StreamingResponse"},{"location":"responses/#fileresponse","text":"Asynchronously streams a file as the response. Takes a different set of arguments to instantiate than the other response types: path - The filepath to the file to stream. headers - Any custom headers to include, as a dictionary. media_type - A string giving the media type. If unset, the filename or path will be used to infer a media type. filename - If set, this will be included in the response Content-Disposition . File responses will include appropriate Content-Length , Last-Modified and ETag headers. from starlette.responses import FileResponse async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = FileResponse ( 'statics/favicon.ico' ) await response ( scope , receive , send )","title":"FileResponse"},{"location":"responses/#third-party-middleware","text":"","title":"Third party middleware"},{"location":"responses/#sseresponseeventsourceresponse","text":"Server Sent Response implements the ServerSentEvent Protocol: https://www.w3.org/TR/2009/WD-eventsource-20090421. It enables event streaming from the server to the client without the complexity of websockets.","title":"SSEResponse(EventSourceResponse)"},{"location":"routing/","text":"Starlette has a simple but capable request routing system. A routing table is defined as a list of routes, and passed when instantiating the application. from starlette.applications import Starlette from starlette.responses import PlainTextResponse from starlette.routing import Route async def homepage ( request ): return PlainTextResponse ( \"Homepage\" ) async def about ( request ): return PlainTextResponse ( \"About\" ) routes = [ Route ( \"/\" , endpoint = homepage ), Route ( \"/about\" , endpoint = about ), ] app = Starlette ( routes = routes ) The endpoint argument can be one of: A regular function or async function, which accepts a single request argument and which should return a response. A class that implements the ASGI interface, such as Starlette's class based views . Path Parameters Paths can use URI templating style to capture path components. Route ( '/users/ {username} ' , user ) By default this will capture characters up to the end of the path or the next / . You can use convertors to modify what is captured. Four convertors are available: str returns a string, and is the default. int returns a Python integer. float returns a Python float. uuid return a Python uuid.UUID instance. path returns the rest of the path, including any additional / characters. Convertors are used by prefixing them with a colon, like so: Route ( '/users/{user_id:int}' , user ) Route ( '/floating-point/{number:float}' , floating_point ) Route ( '/uploaded/{rest_of_path:path}' , uploaded ) Path parameters are made available in the request, as the request.path_params dictionary. async def user ( request ): user_id = request . path_params [ 'user_id' ] ... Handling HTTP methods Routes can also specify which HTTP methods are handled by an endpoint: Route ( '/users/{user_id:int}' , user , methods = [ \"GET\" , \"POST\" ]) By default function endpoints will only accept GET requests, unless specified. Submounting routes In large applications you might find that you want to break out parts of the routing table, based on a common path prefix. routes = [ Route ( '/' , homepage ), Mount ( '/users' , routes = [ Route ( '/' , users , methods = [ 'GET' , 'POST' ]), Route ( '/ {username} ' , user ), ]) ] This style allows you to define different subsets of the routing table in different parts of your project. from myproject import users , auth routes = [ Route ( '/' , homepage ), Mount ( '/users' , routes = users . routes ), Mount ( '/auth' , routes = auth . routes ), ] You can also use mounting to include sub-applications within your Starlette application. For example... # This is a standalone static files server: app = StaticFiles ( directory = \"static\" ) # This is a static files server mounted within a Starlette application, # underneath the \"/static\" path. routes = [ ... Mount ( \"/static\" , app = StaticFiles ( directory = \"static\" ), name = \"static\" ) ] app = Starlette ( routes = routes ) Reverse URL lookups You'll often want to be able to generate the URL for a particular route, such as in cases where you need to return a redirect response. routes = [ Route ( \"/\" , homepage , name = \"homepage\" ) ] # We can use the following to return a URL... url = request . url_for ( \"homepage\" ) URL lookups can include path parameters... routes = [ Route ( \"/users/ {username} \" , user , name = \"user_detail\" ) ] # We can use the following to return a URL... url = request . url_for ( \"user_detail\" , username =... ) If a Mount includes a name , then submounts should use a {prefix}:{name} style for reverse URL lookups. routes = [ Mount ( \"/users\" , name = \"users\" , routes = [ Route ( \"/\" , user , name = \"user_list\" ), Route ( \"/ {username} \" , user , name = \"user_detail\" ) ]) ] # We can use the following to return URLs... url = request . url_for ( \"users:user_list\" ) url = request . url_for ( \"users:user_detail\" , username =... ) Mounted applications may include a path=... parameter. routes = [ ... Mount ( \"/static\" , app = StaticFiles ( directory = \"static\" ), name = \"static\" ) ] # We can use the following to return URLs... url = request . url_for ( \"static\" , path = \"/css/base.css\" ) For cases where there is no request instance, you can make reverse lookups against the application, although these will only return the URL path. url = app . url_path_for ( \"user_detail\" , username =... ) Route priority Incoming paths are matched against each Route in order. In cases where more that one route could match an incoming path, you should take care to ensure that more specific routes are listed before general cases. For example: # Don't do this: `/users/me` will never match incoming requests. routes = [ Route ( '/users/ {username} ' , user ), Route ( '/users/me' , current_user ), ] # Do this: `/users/me` is tested first. routes = [ Route ( '/users/me' , current_user ), Route ( '/users/ {username} ' , user ), ] Working with Router instances If you're working at a low-level you might want to use a plain Router instance, rather that creating a Starlette application. This gives you a lightweight ASGI application that just provides the application routing, without wrapping it up in any middleware. app = Router ( routes = [ Route ( '/' , homepage ), Mount ( '/users' , routes = [ Route ( '/' , users , methods = [ 'GET' , 'POST' ]), Route ( '/ {username} ' , user ), ]) ])","title":"Routing"},{"location":"routing/#path-parameters","text":"Paths can use URI templating style to capture path components. Route ( '/users/ {username} ' , user ) By default this will capture characters up to the end of the path or the next / . You can use convertors to modify what is captured. Four convertors are available: str returns a string, and is the default. int returns a Python integer. float returns a Python float. uuid return a Python uuid.UUID instance. path returns the rest of the path, including any additional / characters. Convertors are used by prefixing them with a colon, like so: Route ( '/users/{user_id:int}' , user ) Route ( '/floating-point/{number:float}' , floating_point ) Route ( '/uploaded/{rest_of_path:path}' , uploaded ) Path parameters are made available in the request, as the request.path_params dictionary. async def user ( request ): user_id = request . path_params [ 'user_id' ] ...","title":"Path Parameters"},{"location":"routing/#handling-http-methods","text":"Routes can also specify which HTTP methods are handled by an endpoint: Route ( '/users/{user_id:int}' , user , methods = [ \"GET\" , \"POST\" ]) By default function endpoints will only accept GET requests, unless specified.","title":"Handling HTTP methods"},{"location":"routing/#submounting-routes","text":"In large applications you might find that you want to break out parts of the routing table, based on a common path prefix. routes = [ Route ( '/' , homepage ), Mount ( '/users' , routes = [ Route ( '/' , users , methods = [ 'GET' , 'POST' ]), Route ( '/ {username} ' , user ), ]) ] This style allows you to define different subsets of the routing table in different parts of your project. from myproject import users , auth routes = [ Route ( '/' , homepage ), Mount ( '/users' , routes = users . routes ), Mount ( '/auth' , routes = auth . routes ), ] You can also use mounting to include sub-applications within your Starlette application. For example... # This is a standalone static files server: app = StaticFiles ( directory = \"static\" ) # This is a static files server mounted within a Starlette application, # underneath the \"/static\" path. routes = [ ... Mount ( \"/static\" , app = StaticFiles ( directory = \"static\" ), name = \"static\" ) ] app = Starlette ( routes = routes )","title":"Submounting routes"},{"location":"routing/#reverse-url-lookups","text":"You'll often want to be able to generate the URL for a particular route, such as in cases where you need to return a redirect response. routes = [ Route ( \"/\" , homepage , name = \"homepage\" ) ] # We can use the following to return a URL... url = request . url_for ( \"homepage\" ) URL lookups can include path parameters... routes = [ Route ( \"/users/ {username} \" , user , name = \"user_detail\" ) ] # We can use the following to return a URL... url = request . url_for ( \"user_detail\" , username =... ) If a Mount includes a name , then submounts should use a {prefix}:{name} style for reverse URL lookups. routes = [ Mount ( \"/users\" , name = \"users\" , routes = [ Route ( \"/\" , user , name = \"user_list\" ), Route ( \"/ {username} \" , user , name = \"user_detail\" ) ]) ] # We can use the following to return URLs... url = request . url_for ( \"users:user_list\" ) url = request . url_for ( \"users:user_detail\" , username =... ) Mounted applications may include a path=... parameter. routes = [ ... Mount ( \"/static\" , app = StaticFiles ( directory = \"static\" ), name = \"static\" ) ] # We can use the following to return URLs... url = request . url_for ( \"static\" , path = \"/css/base.css\" ) For cases where there is no request instance, you can make reverse lookups against the application, although these will only return the URL path. url = app . url_path_for ( \"user_detail\" , username =... )","title":"Reverse URL lookups"},{"location":"routing/#route-priority","text":"Incoming paths are matched against each Route in order. In cases where more that one route could match an incoming path, you should take care to ensure that more specific routes are listed before general cases. For example: # Don't do this: `/users/me` will never match incoming requests. routes = [ Route ( '/users/ {username} ' , user ), Route ( '/users/me' , current_user ), ] # Do this: `/users/me` is tested first. routes = [ Route ( '/users/me' , current_user ), Route ( '/users/ {username} ' , user ), ]","title":"Route priority"},{"location":"routing/#working-with-router-instances","text":"If you're working at a low-level you might want to use a plain Router instance, rather that creating a Starlette application. This gives you a lightweight ASGI application that just provides the application routing, without wrapping it up in any middleware. app = Router ( routes = [ Route ( '/' , homepage ), Mount ( '/users' , routes = [ Route ( '/' , users , methods = [ 'GET' , 'POST' ]), Route ( '/ {username} ' , user ), ]) ])","title":"Working with Router instances"},{"location":"schemas/","text":"Starlette supports generating API schemas, such as the widely used OpenAPI specification . (Formerly known as \"Swagger\".) Schema generation works by inspecting the routes on the application through app.routes , and using the docstrings or other attributes on the endpoints in order to determine a complete API schema. Starlette is not tied to any particular schema generation or validation tooling, but includes a simple implementation that generates OpenAPI schemas based on the docstrings. from starlette.applications import Starlette from starlette.routing import Route from starlette.schemas import SchemaGenerator schemas = SchemaGenerator ( { \"openapi\" : \"3.0.0\" , \"info\" : { \"title\" : \"Example API\" , \"version\" : \"1.0\" }} ) def list_users ( request ): \"\"\" responses: 200: description: A list of users. examples: [{\"username\": \"tom\"}, {\"username\": \"lucy\"}] \"\"\" raise NotImplementedError () def create_user ( request ): \"\"\" responses: 200: description: A user. examples: {\"username\": \"tom\"} \"\"\" raise NotImplementedError () def openapi_schema ( request ): return schemas . OpenAPIResponse ( request = request ) routes = [ Route ( \"/users\" , endpoint = list_users , methods = [ \"GET\" ]) Route ( \"/users\" , endpoint = create_user , methods = [ \"POST\" ]) Route ( \"/schema\" , endpoint = openapi_schema , include_in_schema = False ) ] app = Starlette () We can now access an OpenAPI schema at the \"/schema\" endpoint. You can generate the API Schema directly with .get_schema(routes) : schema = schemas . get_schema ( routes = app . routes ) assert schema == { \"openapi\" : \"3.0.0\" , \"info\" : { \"title\" : \"Example API\" , \"version\" : \"1.0\" }, \"paths\" : { \"/users\" : { \"get\" : { \"responses\" : { 200 : { \"description\" : \"A list of users.\" , \"examples\" : [{ \"username\" : \"tom\" }, { \"username\" : \"lucy\" }], } } }, \"post\" : { \"responses\" : { 200 : { \"description\" : \"A user.\" , \"examples\" : { \"username\" : \"tom\" }} } }, }, }, } You might also want to be able to print out the API schema, so that you can use tooling such as generating API documentation. if __name__ == '__main__' : assert sys . argv [ - 1 ] in ( \"run\" , \"schema\" ), \"Usage: example.py [run|schema]\" if sys . argv [ - 1 ] == \"run\" : uvicorn . run ( \"example:app\" , host = '0.0.0.0' , port = 8000 ) elif sys . argv [ - 1 ] == \"schema\" : schema = schemas . get_schema ( routes = app . routes ) print ( yaml . dump ( schema , default_flow_style = False )) Third party packages starlette-apispec Easy APISpec integration for Starlette, which supports some object serialization libraries.","title":"API Schemas"},{"location":"schemas/#third-party-packages","text":"","title":"Third party packages"},{"location":"schemas/#starlette-apispec","text":"Easy APISpec integration for Starlette, which supports some object serialization libraries.","title":"starlette-apispec"},{"location":"server-push/","text":"Starlette includes support for HTTP/2 and HTTP/3 server push, making it possible to push resources to the client to speed up page load times. Request.send_push_promise Used to initiate a server push for a resource. If server push is not available this method does nothing. Signature: send_push_promise(path) path - A string denoting the path of the resource. from starlette.applications import Starlette from starlette.responses import HTMLResponse from starlette.routing import Route , Mount from starlette.staticfiles import StaticFiles async def homepage ( request ): \"\"\" Homepage which uses server push to deliver the stylesheet. \"\"\" await request . send_push_promise ( \"/static/style.css\" ) return HTMLResponse ( '<html><head><link rel=\"stylesheet\" href=\"/static/style.css\"/></head></html>' ) routes = [ Route ( \"/\" , endpoint = homepage ), Mount ( \"/static\" , StaticFiles ( directory = \"static\" ), name = \"static\" ) ] app = Starlette ( routes = routes )","title":"Server Push"},{"location":"server-push/#requestsend_push_promise","text":"Used to initiate a server push for a resource. If server push is not available this method does nothing. Signature: send_push_promise(path) path - A string denoting the path of the resource. from starlette.applications import Starlette from starlette.responses import HTMLResponse from starlette.routing import Route , Mount from starlette.staticfiles import StaticFiles async def homepage ( request ): \"\"\" Homepage which uses server push to deliver the stylesheet. \"\"\" await request . send_push_promise ( \"/static/style.css\" ) return HTMLResponse ( '<html><head><link rel=\"stylesheet\" href=\"/static/style.css\"/></head></html>' ) routes = [ Route ( \"/\" , endpoint = homepage ), Mount ( \"/static\" , StaticFiles ( directory = \"static\" ), name = \"static\" ) ] app = Starlette ( routes = routes )","title":"Request.send_push_promise"},{"location":"staticfiles/","text":"Starlette also includes a StaticFiles class for serving files in a given directory: StaticFiles Signature: StaticFiles(directory=None, packages=None, check_dir=True) directory - A string or os.Pathlike denoting a directory path. packages - A list of strings of python packages. html - Run in HTML mode. Automatically loads index.html for directories if such file exist. check_dir - Ensure that the directory exists upon instantiation. Defaults to True . You can combine this ASGI application with Starlette's routing to provide comprehensive static file serving. from starlette.applications import Starlette from starlette.routing import Mount from starlette.staticfiles import StaticFiles routes = [ ... Mount ( '/static' , app = StaticFiles ( directory = 'static' ), name = \"static\" ), ] app = Starlette ( routes = routes ) Static files will respond with \"404 Not found\" or \"405 Method not allowed\" responses for requests which do not match. In HTML mode if 404.html file exists it will be shown as 404 response. The packages option can be used to include \"static\" directories contained within a python package. The Python \"bootstrap4\" package is an example of this. from starlette.applications import Starlette from starlette.routing import Mount from starlette.staticfiles import StaticFiles routes = [ ... Mount ( '/static' , app = StaticFiles ( directory = 'static' , packages = [ 'bootstrap4' ]), name = \"static\" ), ] app = Starlette ( routes = routes ) You may prefer to include static files directly inside the \"static\" directory rather than using Python packaging to include static files, but it can be useful for bundling up reusable components.","title":"Static Files"},{"location":"staticfiles/#staticfiles","text":"Signature: StaticFiles(directory=None, packages=None, check_dir=True) directory - A string or os.Pathlike denoting a directory path. packages - A list of strings of python packages. html - Run in HTML mode. Automatically loads index.html for directories if such file exist. check_dir - Ensure that the directory exists upon instantiation. Defaults to True . You can combine this ASGI application with Starlette's routing to provide comprehensive static file serving. from starlette.applications import Starlette from starlette.routing import Mount from starlette.staticfiles import StaticFiles routes = [ ... Mount ( '/static' , app = StaticFiles ( directory = 'static' ), name = \"static\" ), ] app = Starlette ( routes = routes ) Static files will respond with \"404 Not found\" or \"405 Method not allowed\" responses for requests which do not match. In HTML mode if 404.html file exists it will be shown as 404 response. The packages option can be used to include \"static\" directories contained within a python package. The Python \"bootstrap4\" package is an example of this. from starlette.applications import Starlette from starlette.routing import Mount from starlette.staticfiles import StaticFiles routes = [ ... Mount ( '/static' , app = StaticFiles ( directory = 'static' , packages = [ 'bootstrap4' ]), name = \"static\" ), ] app = Starlette ( routes = routes ) You may prefer to include static files directly inside the \"static\" directory rather than using Python packaging to include static files, but it can be useful for bundling up reusable components.","title":"StaticFiles"},{"location":"templates/","text":"Starlette is not strictly coupled to any particular templating engine, but Jinja2 provides an excellent choice. Starlette provides a simple way to get jinja2 configured. This is probably what you want to use by default. from starlette.applications import Starlette from starlette.routing import Route , Mount from starlette.templating import Jinja2Templates from starlette.staticfiles import StaticFiles templates = Jinja2Templates ( directory = 'templates' ) async def homepage ( request ): return templates . TemplateResponse ( 'index.html' , { 'request' : request }) routes = [ Route ( '/' , endpoint = homepage ), Mount ( '/static' , StaticFiles ( directory = 'static' ), name = 'static' ) ] app = Starlette ( debug = True , routes = routes ) Note that the incoming request instance must be included as part of the template context. The Jinja2 template context will automatically include a url_for function, so we can correctly hyperlink to other pages within the application. For example, we can link to static files from within our HTML templates: < link href = \"{{ url_for('static', path='/css/bootstrap.min.css') }}\" rel = \"stylesheet\" > If you want to use custom filters , you will need to update the env property of Jinja2Templates : from commonmark import commonmark from starlette.templating import Jinja2Templates def marked_filter ( text ): return commonmark ( text ) templates = Jinja2Templates ( directory = 'templates' ) templates . env . filters [ 'marked' ] = marked_filter Testing template responses When using the test client, template responses include .template and .context attributes. def test_homepage (): client = TestClient ( app ) response = client . get ( \"/\" ) assert response . status_code == 200 assert response . template . name == 'index.html' assert \"request\" in response . context Asynchronous template rendering Jinja2 supports async template rendering, however as a general rule we'd recommend that you keep your templates free from logic that invokes database lookups, or other I/O operations. Instead we'd recommend that you ensure that your endpoints perform all I/O, for example, strictly evaluate any database queries within the view and include the final results in the context.","title":"Templates"},{"location":"templates/#testing-template-responses","text":"When using the test client, template responses include .template and .context attributes. def test_homepage (): client = TestClient ( app ) response = client . get ( \"/\" ) assert response . status_code == 200 assert response . template . name == 'index.html' assert \"request\" in response . context","title":"Testing template responses"},{"location":"templates/#asynchronous-template-rendering","text":"Jinja2 supports async template rendering, however as a general rule we'd recommend that you keep your templates free from logic that invokes database lookups, or other I/O operations. Instead we'd recommend that you ensure that your endpoints perform all I/O, for example, strictly evaluate any database queries within the view and include the final results in the context.","title":"Asynchronous template rendering"},{"location":"testclient/","text":"The test client allows you to make requests against your ASGI application, using the requests library. from starlette.responses import HTMLResponse from starlette.testclient import TestClient async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = HTMLResponse ( '<html><body>Hello, world!</body></html>' ) await response ( scope , receive , send ) def test_app (): client = TestClient ( app ) response = client . get ( '/' ) assert response . status_code == 200 The test client exposes the same interface as any other requests session. In particular, note that the calls to make a request are just standard function calls, not awaitables. You can use any of requests standard API, such as authentication, session cookies handling, or file uploads. By default the TestClient will raise any exceptions that occur in the application. Occasionally you might want to test the content of 500 error responses, rather than allowing client to raise the server exception. In this case you should use client = TestClient(app, raise_server_exceptions=False) . Selecting the Async backend TestClient takes arguments backend (a string) and backend_options (a dictionary). These options are passed to anyio.start_blocking_portal() . See the anyio documentation for more information about the accepted backend options. By default, asyncio is used with default options. To run Trio , pass backend=\"trio\" . For example: def test_app () with TestClient ( app , backend = \"trio\" ) as client : ... To run asyncio with uvloop , pass backend_options={\"use_uvloop\": True} . For example: def test_app () with TestClient ( app , backend_options = { \"use_uvloop\" : True }) as client : ... Testing WebSocket sessions You can also test websocket sessions with the test client. The requests library will be used to build the initial handshake, meaning you can use the same authentication options and other headers between both http and websocket testing. from starlette.testclient import TestClient from starlette.websockets import WebSocket async def app ( scope , receive , send ): assert scope [ 'type' ] == 'websocket' websocket = WebSocket ( scope , receive = receive , send = send ) await websocket . accept () await websocket . send_text ( 'Hello, world!' ) await websocket . close () def test_app (): client = TestClient ( app ) with client . websocket_connect ( '/' ) as websocket : data = websocket . receive_text () assert data == 'Hello, world!' The operations on session are standard function calls, not awaitables. It's important to use the session within a context-managed with block. This ensure that the background thread on which the ASGI application is properly terminated, and that any exceptions that occur within the application are always raised by the test client. Establishing a test session .websocket_connect(url, subprotocols=None, **options) - Takes the same set of arguments as requests.get() . May raise starlette.websockets.WebSocketDisconnect if the application does not accept the websocket connection. websocket_connect() must be used as a context manager (in a with block). Sending data .send_text(data) - Send the given text to the application. .send_bytes(data) - Send the given bytes to the application. .send_json(data, mode=\"text\") - Send the given data to the application. Use mode=\"binary\" to send JSON over binary data frames. Receiving data .receive_text() - Wait for incoming text sent by the application and return it. .receive_bytes() - Wait for incoming bytestring sent by the application and return it. .receive_json(mode=\"text\") - Wait for incoming json data sent by the application and return it. Use mode=\"binary\" to send JSON over binary data frames. May raise starlette.websockets.WebSocketDisconnect . Closing the connection .close(code=1000) - Perform a client-side close of the websocket connection.","title":"Test Client"},{"location":"testclient/#selecting-the-async-backend","text":"TestClient takes arguments backend (a string) and backend_options (a dictionary). These options are passed to anyio.start_blocking_portal() . See the anyio documentation for more information about the accepted backend options. By default, asyncio is used with default options. To run Trio , pass backend=\"trio\" . For example: def test_app () with TestClient ( app , backend = \"trio\" ) as client : ... To run asyncio with uvloop , pass backend_options={\"use_uvloop\": True} . For example: def test_app () with TestClient ( app , backend_options = { \"use_uvloop\" : True }) as client : ...","title":"Selecting the Async backend"},{"location":"testclient/#testing-websocket-sessions","text":"You can also test websocket sessions with the test client. The requests library will be used to build the initial handshake, meaning you can use the same authentication options and other headers between both http and websocket testing. from starlette.testclient import TestClient from starlette.websockets import WebSocket async def app ( scope , receive , send ): assert scope [ 'type' ] == 'websocket' websocket = WebSocket ( scope , receive = receive , send = send ) await websocket . accept () await websocket . send_text ( 'Hello, world!' ) await websocket . close () def test_app (): client = TestClient ( app ) with client . websocket_connect ( '/' ) as websocket : data = websocket . receive_text () assert data == 'Hello, world!' The operations on session are standard function calls, not awaitables. It's important to use the session within a context-managed with block. This ensure that the background thread on which the ASGI application is properly terminated, and that any exceptions that occur within the application are always raised by the test client.","title":"Testing WebSocket sessions"},{"location":"testclient/#establishing-a-test-session","text":".websocket_connect(url, subprotocols=None, **options) - Takes the same set of arguments as requests.get() . May raise starlette.websockets.WebSocketDisconnect if the application does not accept the websocket connection. websocket_connect() must be used as a context manager (in a with block).","title":"Establishing a test session"},{"location":"testclient/#sending-data","text":".send_text(data) - Send the given text to the application. .send_bytes(data) - Send the given bytes to the application. .send_json(data, mode=\"text\") - Send the given data to the application. Use mode=\"binary\" to send JSON over binary data frames.","title":"Sending data"},{"location":"testclient/#receiving-data","text":".receive_text() - Wait for incoming text sent by the application and return it. .receive_bytes() - Wait for incoming bytestring sent by the application and return it. .receive_json(mode=\"text\") - Wait for incoming json data sent by the application and return it. Use mode=\"binary\" to send JSON over binary data frames. May raise starlette.websockets.WebSocketDisconnect .","title":"Receiving data"},{"location":"testclient/#closing-the-connection","text":".close(code=1000) - Perform a client-side close of the websocket connection.","title":"Closing the connection"},{"location":"third-party-packages/","text":"Starlette has a rapidly growing community of developers, building tools that integrate into Starlette, tools that depend on Starlette, etc. Here are some of those third party packages: Backports Python 3.5 port GitHub Plugins Starlette APISpec GitHub Simple APISpec integration for Starlette. Document your REST API built with Starlette by declaring OpenAPI (Swagger) schemas in YAML format in your endpoint's docstrings. SpecTree GitHub Generate OpenAPI spec document and validate request & response with Python annotations. Less boilerplate code(no need for YAML). Mangum GitHub Serverless ASGI adapter for AWS Lambda & API Gateway. Nejma GitHub Manage and send messages to groups of channels using websockets. Checkout nejma-chat , a simple chat application built using nejma and starlette . ChannelBox GitHub Another solution for websocket broadcast. Send messages to channel groups from any part of your code. Checkout channel-box-chat , a simple chat application built using channel-box and starlette . Scout APM GitHub An APM (Application Performance Monitoring) solution that can instrument your application to find performance bottlenecks. Starlette Prometheus GitHub A plugin for providing an endpoint that exposes Prometheus metrics based on its official python client . webargs-starlette GitHub Declarative request parsing and validation for Starlette, built on top of webargs . Allows you to parse querystring, JSON, form, headers, and cookies using type annotations. Authlib GitHub | Documentation The ultimate Python library in building OAuth and OpenID Connect clients and servers. Check out how to integrate with Starlette . Starlette OAuth2 API GitLab A starlette middleware to add authentication and authorization through JWTs. It relies solely on an auth provider to issue access and/or id tokens to clients. Starlette Context GitHub Middleware for Starlette that allows you to store and access the context data of a request. Can be used with logging so logs automatically use request headers such as x-request-id or x-correlation-id. Frameworks Responder GitHub | Documentation Async web service framework. Some Features: flask-style route expression, yaml support, OpenAPI schema generation, background tasks, graphql. FastAPI GitHub | Documentation High performance, easy to learn, fast to code, ready for production web API framework. Inspired by APIStar 's previous server system with type declarations for route parameters, based on the OpenAPI specification version 3.0.0+ (with JSON Schema), powered by Pydantic for the data handling. Flama GitHub | Documentation Formerly Starlette API. Flama aims to bring a layer on top of Starlette to provide an easy to learn and fast to develop approach for building highly performant GraphQL and REST APIs. In the same way of Starlette is, Flama is a perfect option for developing asynchronous and production-ready services.","title":"Third Party Packages"},{"location":"third-party-packages/#backports","text":"","title":"Backports"},{"location":"third-party-packages/#python-35-port","text":"GitHub","title":"Python 3.5 port"},{"location":"third-party-packages/#plugins","text":"","title":"Plugins"},{"location":"third-party-packages/#starlette-apispec","text":"GitHub Simple APISpec integration for Starlette. Document your REST API built with Starlette by declaring OpenAPI (Swagger) schemas in YAML format in your endpoint's docstrings.","title":"Starlette APISpec"},{"location":"third-party-packages/#spectree","text":"GitHub Generate OpenAPI spec document and validate request & response with Python annotations. Less boilerplate code(no need for YAML).","title":"SpecTree"},{"location":"third-party-packages/#mangum","text":"GitHub Serverless ASGI adapter for AWS Lambda & API Gateway.","title":"Mangum"},{"location":"third-party-packages/#nejma","text":"GitHub Manage and send messages to groups of channels using websockets. Checkout nejma-chat , a simple chat application built using nejma and starlette .","title":"Nejma"},{"location":"third-party-packages/#channelbox","text":"GitHub Another solution for websocket broadcast. Send messages to channel groups from any part of your code. Checkout channel-box-chat , a simple chat application built using channel-box and starlette .","title":"ChannelBox"},{"location":"third-party-packages/#scout-apm","text":"GitHub An APM (Application Performance Monitoring) solution that can instrument your application to find performance bottlenecks.","title":"Scout APM"},{"location":"third-party-packages/#starlette-prometheus","text":"GitHub A plugin for providing an endpoint that exposes Prometheus metrics based on its official python client .","title":"Starlette Prometheus"},{"location":"third-party-packages/#webargs-starlette","text":"GitHub Declarative request parsing and validation for Starlette, built on top of webargs . Allows you to parse querystring, JSON, form, headers, and cookies using type annotations.","title":"webargs-starlette"},{"location":"third-party-packages/#authlib","text":"GitHub | Documentation The ultimate Python library in building OAuth and OpenID Connect clients and servers. Check out how to integrate with Starlette .","title":"Authlib"},{"location":"third-party-packages/#starlette-oauth2-api","text":"GitLab A starlette middleware to add authentication and authorization through JWTs. It relies solely on an auth provider to issue access and/or id tokens to clients.","title":"Starlette OAuth2 API"},{"location":"third-party-packages/#starlette-context","text":"GitHub Middleware for Starlette that allows you to store and access the context data of a request. Can be used with logging so logs automatically use request headers such as x-request-id or x-correlation-id.","title":"Starlette Context"},{"location":"third-party-packages/#frameworks","text":"","title":"Frameworks"},{"location":"third-party-packages/#responder","text":"GitHub | Documentation Async web service framework. Some Features: flask-style route expression, yaml support, OpenAPI schema generation, background tasks, graphql.","title":"Responder"},{"location":"third-party-packages/#fastapi","text":"GitHub | Documentation High performance, easy to learn, fast to code, ready for production web API framework. Inspired by APIStar 's previous server system with type declarations for route parameters, based on the OpenAPI specification version 3.0.0+ (with JSON Schema), powered by Pydantic for the data handling.","title":"FastAPI"},{"location":"third-party-packages/#flama","text":"GitHub | Documentation Formerly Starlette API. Flama aims to bring a layer on top of Starlette to provide an easy to learn and fast to develop approach for building highly performant GraphQL and REST APIs. In the same way of Starlette is, Flama is a perfect option for developing asynchronous and production-ready services.","title":"Flama"},{"location":"websockets/","text":"Starlette includes a WebSocket class that fulfils a similar role to the HTTP request, but that allows sending and receiving data on a websocket. WebSocket Signature: WebSocket(scope, receive=None, send=None) from starlette.websockets import WebSocket async def app ( scope , receive , send ): websocket = WebSocket ( scope = scope , receive = receive , send = send ) await websocket . accept () await websocket . send_text ( 'Hello, world!' ) await websocket . close () WebSockets present a mapping interface, so you can use them in the same way as a scope . For instance: websocket['path'] will return the ASGI path. URL The websocket URL is accessed as websocket.url . The property is actually a subclass of str , and also exposes all the components that can be parsed out of the URL. For example: websocket.url.path , websocket.url.port , websocket.url.scheme . Headers Headers are exposed as an immutable, case-insensitive, multi-dict. For example: websocket.headers['sec-websocket-version'] Query Parameters Query parameters are exposed as an immutable multi-dict. For example: websocket.query_params['search'] Path Parameters Router path parameters are exposed as a dictionary interface. For example: websocket.path_params['username'] Accepting the connection await websocket.accept(subprotocol=None) Sending data await websocket.send_text(data) await websocket.send_bytes(data) await websocket.send_json(data) JSON messages default to being sent over text data frames, from version 0.10.0 onwards. Use websocket.send_json(data, mode=\"binary\") to send JSON over binary data frames. Receiving data await websocket.receive_text() await websocket.receive_bytes() await websocket.receive_json() May raise starlette.websockets.WebSocketDisconnect() . JSON messages default to being received over text data frames, from version 0.10.0 onwards. Use websocket.receive_json(data, mode=\"binary\") to receive JSON over binary data frames. Closing the connection await websocket.close(code=1000) Sending and receiving messages If you need to send or receive raw ASGI messages then you should use websocket.send() and websocket.receive() rather than using the raw send and receive callables. This will ensure that the websocket's state is kept correctly updated. await websocket.send(message) await websocket.receive()","title":"WebSockets"},{"location":"websockets/#websocket","text":"Signature: WebSocket(scope, receive=None, send=None) from starlette.websockets import WebSocket async def app ( scope , receive , send ): websocket = WebSocket ( scope = scope , receive = receive , send = send ) await websocket . accept () await websocket . send_text ( 'Hello, world!' ) await websocket . close () WebSockets present a mapping interface, so you can use them in the same way as a scope . For instance: websocket['path'] will return the ASGI path.","title":"WebSocket"},{"location":"websockets/#url","text":"The websocket URL is accessed as websocket.url . The property is actually a subclass of str , and also exposes all the components that can be parsed out of the URL. For example: websocket.url.path , websocket.url.port , websocket.url.scheme .","title":"URL"},{"location":"websockets/#headers","text":"Headers are exposed as an immutable, case-insensitive, multi-dict. For example: websocket.headers['sec-websocket-version']","title":"Headers"},{"location":"websockets/#query-parameters","text":"Query parameters are exposed as an immutable multi-dict. For example: websocket.query_params['search']","title":"Query Parameters"},{"location":"websockets/#path-parameters","text":"Router path parameters are exposed as a dictionary interface. For example: websocket.path_params['username']","title":"Path Parameters"},{"location":"websockets/#accepting-the-connection","text":"await websocket.accept(subprotocol=None)","title":"Accepting the connection"},{"location":"websockets/#sending-data","text":"await websocket.send_text(data) await websocket.send_bytes(data) await websocket.send_json(data) JSON messages default to being sent over text data frames, from version 0.10.0 onwards. Use websocket.send_json(data, mode=\"binary\") to send JSON over binary data frames.","title":"Sending data"},{"location":"websockets/#receiving-data","text":"await websocket.receive_text() await websocket.receive_bytes() await websocket.receive_json() May raise starlette.websockets.WebSocketDisconnect() . JSON messages default to being received over text data frames, from version 0.10.0 onwards. Use websocket.receive_json(data, mode=\"binary\") to receive JSON over binary data frames.","title":"Receiving data"},{"location":"websockets/#closing-the-connection","text":"await websocket.close(code=1000)","title":"Closing the connection"},{"location":"websockets/#sending-and-receiving-messages","text":"If you need to send or receive raw ASGI messages then you should use websocket.send() and websocket.receive() rather than using the raw send and receive callables. This will ensure that the websocket's state is kept correctly updated. await websocket.send(message) await websocket.receive()","title":"Sending and receiving messages"}]}